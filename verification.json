{"language":"Solidity","sources":{"src/RolloverVault.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.20;\n\nimport {IRolloverVault} from \"./interfaces/IRolloverVault/IRolloverVault.sol\";\nimport {IERC165, LiquidityVault} from \"./LiquidityVault.sol\";\nimport {Math} from \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {IGeneralManager} from \"@core/interfaces/IGeneralManager/IGeneralManager.sol\";\nimport {IOriginationPool} from \"@core/interfaces/IOriginationPool/IOriginationPool.sol\";\nimport {IOriginationPoolScheduler} from \"@core/interfaces/IOriginationPoolScheduler/IOriginationPoolScheduler.sol\";\n\n/**\n * @title FulfillmentVault\n * @author @SocksNFlops\n * @notice The RolloverVault contract used to automatically rotate unused assets into origination pools.\n */\ncontract RolloverVault is LiquidityVault, IRolloverVault {\n  using Math for uint256;\n\n  /// @notice Allow the contract to receive network native tokens (HYPE bridged from Core)\n  receive() external payable {}\n\n  /**\n   * @custom:storage-location erc7201:buttonwood.storage.RolloverVault\n   * @notice The storage for the RolloverVault contract\n   * @param _usdx The address of the USDX token\n   * @param _consol The address of the consol token\n   * @param _generalManager The address of the general manager\n   * @param _originationPools The addresses of the origination pools the rollover vault currently has a balance in\n   * @param _poolIndex Mapping of origination pool addresses to their index in the _originationPools array (offset by 1)\n   */\n  struct RolloverVaultStorage {\n    address _usdx;\n    address _consol;\n    address _generalManager;\n    address[] _originationPools;\n    mapping(address => uint256) _poolIndex;\n  }\n\n  /**\n   * @notice The storage location of the RolloverVault contract\n   * @dev keccak256(abi.encode(uint256(keccak256(\"buttonwood.storage.RolloverVault\")) - 1)) & ~bytes32(uint256(0xff))\n   */\n  // solhint-disable-next-line const-name-snakecase\n  bytes32 private constant RolloverVaultStorageLocation =\n    0x3f3d57a95a7cc1b3218bff2f60330bfeb789b9a101fe5e689535b16f8256e000;\n\n  /**\n   * @dev Gets the storage location of the RolloverVault contract\n   * @return $ The storage location of the RolloverVault contract\n   */\n  function _getRolloverVaultStorage() private pure returns (RolloverVaultStorage storage $) {\n    // solhint-disable-next-line no-inline-assembly\n    assembly {\n      $.slot := RolloverVaultStorageLocation\n    }\n  }\n\n  /**\n   * @dev Initializes the RolloverVault contract and calls parent initializers\n   * @param name The name of the rollover vault\n   * @param symbol The symbol of the rollover vault\n   * @param _decimals The decimals of the rollover vault\n   * @param _decimalsOffset The decimals offset for measuring internal precision of shares\n   * @param _generalManager The address of the general manager\n   */\n  // solhint-disable-next-line func-name-mixedcase\n  function __RolloverVault_init(\n    string memory name,\n    string memory symbol,\n    uint8 _decimals,\n    uint8 _decimalsOffset,\n    address _generalManager\n  ) internal onlyInitializing {\n    __ERC20_init_unchained(name, symbol);\n    address[] memory depositableAssets = new address[](1);\n    depositableAssets[0] = IGeneralManager(_generalManager).usdx();\n    address[] memory redeemableAssets = new address[](2);\n    redeemableAssets[0] = IGeneralManager(_generalManager).usdx();\n    redeemableAssets[1] = IGeneralManager(_generalManager).consol();\n    __LiquidityVault_init_unchained(_decimals, _decimalsOffset, depositableAssets, redeemableAssets);\n    __RolloverVault_init_unchained(_generalManager);\n  }\n\n  /**\n   * @dev Initializes the RolloverVault contract only\n   * @param _generalManager The address of the general manager\n   */\n  // solhint-disable-next-line func-name-mixedcase\n  function __RolloverVault_init_unchained(address _generalManager) internal onlyInitializing {\n    RolloverVaultStorage storage $ = _getRolloverVaultStorage();\n    $._generalManager = _generalManager;\n    $._usdx = IGeneralManager(_generalManager).usdx();\n    $._consol = IGeneralManager(_generalManager).consol();\n  }\n\n  /**\n   * @notice Initializes the RolloverVault contract\n   * @param name The name of the rollover vault\n   * @param symbol The symbol of the rollover vault\n   * @param _decimals The decimals of the rollover vault\n   * @param _decimalsOffset The decimals offset for measuring internal precision of shares\n   * @param _generalManager The address of the general manager\n   * @param admin The address of the admin for the rollover vault\n   */\n  function initialize(\n    string memory name,\n    string memory symbol,\n    uint8 _decimals,\n    uint8 _decimalsOffset,\n    address _generalManager,\n    address admin\n  ) external initializer {\n    __RolloverVault_init(name, symbol, _decimals, _decimalsOffset, _generalManager);\n    _grantRole(DEFAULT_ADMIN_ROLE, admin);\n  }\n\n  /// @inheritdoc IERC165\n  function supportsInterface(bytes4 interfaceId) public view override(LiquidityVault) returns (bool) {\n    return super.supportsInterface(interfaceId) || interfaceId == type(IRolloverVault).interfaceId;\n  }\n\n  /// @inheritdoc LiquidityVault\n  function _totalAssets() internal view override returns (uint256) {\n    RolloverVaultStorage storage $ = _getRolloverVaultStorage();\n    uint256 total = 0;\n    // Iterate over all of the origination pools and add of the USDX and Consol balances that will be redeemed by the rollover vault\n    for (uint256 i = 0; i < $._originationPools.length; i++) {\n      IOriginationPool ogPool = IOriginationPool($._originationPools[i]);\n      uint256 ogPoolTotalSupply = ogPool.totalSupply();\n      uint256 ogPoolUsdxBalance = IERC20(usdx()).balanceOf(address(ogPool));\n      uint256 ogPoolConsolBalance = IERC20(consol()).balanceOf(address(ogPool));\n      uint256 ogPoolBalance = ogPool.balanceOf(address(this));\n      total += Math.mulDiv(ogPoolBalance, ogPoolUsdxBalance, ogPoolTotalSupply)\n        + Math.mulDiv(ogPoolBalance, ogPoolConsolBalance, ogPoolTotalSupply);\n    }\n    // Add the USDX and Consol balances that are currently in the rollover vault\n    total += IERC20(usdx()).balanceOf(address(this)) + IERC20(consol()).balanceOf(address(this));\n    // Return the total assets\n    return total;\n  }\n\n  /// @inheritdoc IRolloverVault\n  function usdx() public view override returns (address) {\n    return _getRolloverVaultStorage()._usdx;\n  }\n\n  /// @inheritdoc IRolloverVault\n  function consol() public view override returns (address) {\n    return _getRolloverVaultStorage()._consol;\n  }\n\n  /// @inheritdoc IRolloverVault\n  function generalManager() public view override returns (address) {\n    return _getRolloverVaultStorage()._generalManager;\n  }\n\n  /// @inheritdoc IRolloverVault\n  function originationPoolScheduler() public view returns (address) {\n    return IGeneralManager(generalManager()).originationPoolScheduler();\n  }\n\n  /// @inheritdoc IRolloverVault\n  function originationPools() external view override returns (address[] memory) {\n    return _getRolloverVaultStorage()._originationPools;\n  }\n\n  /// @inheritdoc IRolloverVault\n  function isTracked(address originationPool) external view returns (bool) {\n    return _getRolloverVaultStorage()._poolIndex[originationPool] != 0;\n  }\n\n  /// @inheritdoc IRolloverVault\n  function depositOriginationPool(address originationPool, uint256 amount) external onlyRole(KEEPER_ROLE) whenPaused {\n    // Get the storage\n    RolloverVaultStorage storage $ = _getRolloverVaultStorage();\n\n    // Validate that the origination pool is registered\n    if (!IOriginationPoolScheduler(originationPoolScheduler()).isRegistered(originationPool)) {\n      revert OriginationPoolNotRegistered(originationPool);\n    }\n\n    // Validate that the amount is not zero\n    if (amount == 0) {\n      revert AmountIsZero();\n    }\n\n    // Check if the origination pool is already being tracked. If not, add it to the maps\n    if ($._poolIndex[originationPool] == 0) {\n      $._poolIndex[originationPool] = $._originationPools.length + 1;\n      $._originationPools.push(originationPool);\n      // Update the assets\n      _updateAssets(originationPool, true, true);\n      // Emit the origination pool added event\n      emit OriginationPoolAdded(originationPool);\n    }\n\n    // Emit the deposit event\n    emit OriginationPoolDeposited(originationPool, amount);\n\n    // Deposit usdx into the origination pool\n    IERC20(usdx()).approve(originationPool, amount);\n    IOriginationPool(originationPool).deposit(amount);\n  }\n\n  /// @inheritdoc IRolloverVault\n  function redeemOriginationPool(address originationPool) external onlyRole(KEEPER_ROLE) whenPaused {\n    // Get the storage\n    RolloverVaultStorage storage $ = _getRolloverVaultStorage();\n\n    // Validate the the origination pool is being tracked\n    if ($._poolIndex[originationPool] == 0) {\n      revert OriginationPoolNotTracked(originationPool);\n    }\n\n    // Replace the origination pool with the last origination pool in the list\n    $._originationPools[$._poolIndex[originationPool] - 1] = $._originationPools[$._originationPools.length - 1];\n    $._poolIndex[$._originationPools[$._poolIndex[originationPool] - 1]] = $._poolIndex[originationPool];\n    delete $._poolIndex[originationPool];\n    $._originationPools.pop();\n\n    // Update the assets\n    _updateAssets(originationPool, true, false);\n\n    // Emit the redeem event\n    uint256 ogPoolBalance = IOriginationPool(originationPool).balanceOf(address(this));\n    emit OriginationPoolRedeemed(originationPool, ogPoolBalance);\n\n    // Redeem entire balance of origination pool\n    IOriginationPool(originationPool).redeem(ogPoolBalance);\n  }\n}\n"},"src/interfaces/IRolloverVault/IRolloverVault.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.20;\n\nimport {ILiquidityVault} from \"../ILiquidityVault/ILiquidityVault.sol\";\nimport {IRolloverVaultEvents} from \"./IRolloverVaultEvents.sol\";\nimport {IRolloverVaultErrors} from \"./IRolloverVaultErrors.sol\";\n\n/**\n * @title IRolloverVault\n * @author @SocksNFlops\n * @notice Interface for RolloverVault, a vault that facilitates automatically rotates unused assets into origination pools.\n */\ninterface IRolloverVault is ILiquidityVault, IRolloverVaultEvents, IRolloverVaultErrors {\n  /**\n   * @notice Gets the address of the USDX token\n   * @return The address of the USDX token\n   */\n  function usdx() external view returns (address);\n\n  /**\n   * @notice Gets the address of the consol token\n   * @return The address of the consol token\n   */\n  function consol() external view returns (address);\n\n  /**\n   * @notice Gets the address of the general manager\n   * @return The address of the general manager\n   */\n  function generalManager() external view returns (address);\n\n  /**\n   * @notice Gets the address of the origination pool scheduler\n   * @return The address of the origination pool scheduler\n   */\n  function originationPoolScheduler() external view returns (address);\n\n  /**\n   * @notice Gets the addresses of the origination pools the rollover vault currently has a balance in\n   * @return The addresses of the origination pools the rollover vault currently has a balance in\n   */\n  function originationPools() external view returns (address[] memory);\n\n  /**\n   * @notice Checks if the given origination pool is being tracked by the rollover vault\n   * @param originationPool The address of the origination pool to check if it is being tracked\n   * @return True if the origination pool is being tracked, false otherwise\n   */\n  function isTracked(address originationPool) external view returns (bool);\n\n  /**\n   * @notice Deposits the given amount of the given origination pool into the rollover vault\n   * @param originationPool The address of the origination pool to deposit into\n   * @param amount The amount of the origination pool to deposit\n   */\n  function depositOriginationPool(address originationPool, uint256 amount) external;\n\n  /**\n   * @notice Redeems the entire balance of the given origination pool from the rollover vault\n   * @param originationPool The address of the origination pool to redeem from\n   */\n  function redeemOriginationPool(address originationPool) external;\n}\n"},"src/LiquidityVault.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.20;\n\nimport {ILiquidityVault} from \"./interfaces/ILiquidityVault/ILiquidityVault.sol\";\nimport {ERC20Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\nimport {ERC165Upgradeable} from \"@openzeppelin/contracts-upgradeable/utils/introspection/ERC165Upgradeable.sol\";\nimport {AccessControlUpgradeable} from \"@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol\";\nimport {UUPSUpgradeable} from \"@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol\";\nimport {IERC165} from \"@openzeppelin/contracts/interfaces/IERC165.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {IERC20Metadata} from \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport {IAccessControl} from \"@openzeppelin/contracts/access/IAccessControl.sol\";\nimport {IERC1822Proxiable} from \"@openzeppelin/contracts/interfaces/draft-IERC1822.sol\";\nimport {PausableUpgradeable} from \"@openzeppelin/contracts-upgradeable/utils/PausableUpgradeable.sol\";\nimport {Math} from \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\n/**\n * @title LiquidityVault\n * @author @SocksNFlops\n * @notice The base liquidity vault contract used by FulfillmentVault and RolloverVault\n */\nabstract contract LiquidityVault is\n  ILiquidityVault,\n  ERC165Upgradeable,\n  AccessControlUpgradeable,\n  PausableUpgradeable,\n  UUPSUpgradeable,\n  ERC20Upgradeable\n{\n  using Math for uint256;\n  using SafeERC20 for IERC20;\n\n  /// @inheritdoc ILiquidityVault\n  bytes32 public constant KEEPER_ROLE = keccak256(\"KEEPER_ROLE\");\n\n  /// @inheritdoc ILiquidityVault\n  bytes32 public constant WHITELIST_ROLE = keccak256(\"WHITELIST_ROLE\");\n\n  /**\n   * @custom:storage-location erc7201:buttonwood.storage.LiquidityVault\n   * @notice The storage for the LiquidityVault contract\n   * @param _decimals The decimals of the vault\n   * @param _decimalsOffset The decimals offset for measuring internal precision of shares\n   * @param _depositableAssets The addresses of the depositable assets\n   * @param _depositableAssetIndex The index of the depositable assets (one-indexed)\n   * @param _redeemableAssets The addresses of the redeemable assets\n   * @param _redeemableAssetIndex The index of the redeemable assets (one-indexed)\n   * @param _whitelistEnforced Whether the whitelist is enforced\n   */\n  struct LiquidityVaultStorage {\n    uint8 _decimals;\n    uint8 _decimalsOffset;\n    address[] _depositableAssets;\n    mapping(address => uint256) _depositableAssetIndex;\n    address[] _redeemableAssets;\n    mapping(address => uint256) _redeemableAssetIndex;\n    bool _whitelistEnforced;\n  }\n\n  /**\n   * @notice The storage location of the LiquidityVault contract\n   * @dev keccak256(abi.encode(uint256(keccak256(\"buttonwood.storage.LiquidityVault\")) - 1)) & ~bytes32(uint256(0xff))\n   */\n  // solhint-disable-next-line const-name-snakecase\n  bytes32 private constant LiquidityVaultStorageLocation =\n    0x279d7268e134fe9470212f64c617da0df55170c0eafa03169b80558ce404b000;\n\n  /**\n   * @dev Gets the storage location of the LiquidityVault contract\n   * @return $ The storage location of the LiquidityVault contract\n   */\n  function _getLiquidityVaultStorage() private pure returns (LiquidityVaultStorage storage $) {\n    // solhint-disable-next-line no-inline-assembly\n    assembly {\n      $.slot := LiquidityVaultStorageLocation\n    }\n  }\n\n  /**\n   * @dev Initializes the LiquidityVault contract and calls parent initializers\n   * @param name The name of the liquidity vault\n   * @param symbol The symbol of the liquidity vault\n   * @param _decimals The decimals of the liquidity vault\n   * @param _decimalsOffset The decimals offset for measuring internal precision of shares\n   * @param _depositableAssets The addresses of the depositable assets\n   * @param _redeemableAssets The addresses of the redeemable assets\n   */\n  // solhint-disable-next-line func-name-mixedcase\n  function __LiquidityVault_init(\n    string memory name,\n    string memory symbol,\n    uint8 _decimals,\n    uint8 _decimalsOffset,\n    address[] memory _depositableAssets,\n    address[] memory _redeemableAssets\n  ) internal onlyInitializing {\n    __ERC20_init_unchained(name, symbol);\n    __LiquidityVault_init_unchained(_decimals, _decimalsOffset, _depositableAssets, _redeemableAssets);\n  }\n\n  /**\n   * @dev Initializes the LiquidityVault contract only\n   * @param _decimals The decimals of the liquidity vault\n   * @param _decimalsOffset The decimals offset for measuring internal precision of shares\n   * @param _depositableAssets The addresses of the depositable assets\n   * @param _redeemableAssets The addresses of the redeemable assets\n   */\n  // solhint-disable-next-line func-name-mixedcase\n  function __LiquidityVault_init_unchained(\n    uint8 _decimals,\n    uint8 _decimalsOffset,\n    address[] memory _depositableAssets,\n    address[] memory _redeemableAssets\n  ) internal onlyInitializing {\n    LiquidityVaultStorage storage $ = _getLiquidityVaultStorage();\n    $._decimals = _decimals;\n    $._decimalsOffset = _decimalsOffset;\n    $._depositableAssets = _depositableAssets;\n    for (uint256 i = 0; i < _depositableAssets.length; i++) {\n      $._depositableAssetIndex[_depositableAssets[i]] = i + 1;\n    }\n    $._redeemableAssets = _redeemableAssets;\n    for (uint256 i = 0; i < _redeemableAssets.length; i++) {\n      $._redeemableAssetIndex[_redeemableAssets[i]] = i + 1;\n    }\n    $._whitelistEnforced = false;\n  }\n\n  /**\n   * @notice Initializes the LiquidityVault contract\n   * @param name The name of the liquidity vault\n   * @param symbol The symbol of the liquidity vault\n   * @param _decimals The decimals of the liquidity vault\n   * @param _decimalsOffset The decimals offset for measuring internal precision of shares\n   * @param _depositableAssets The addresses of the depositable assets\n   * @param _redeemableAssets The addresses of the redeemable assets\n   * @param admin The address of the admin for the liquidity vault\n   */\n  function initialize(\n    string memory name,\n    string memory symbol,\n    uint8 _decimals,\n    uint8 _decimalsOffset,\n    address[] memory _depositableAssets,\n    address[] memory _redeemableAssets,\n    address admin\n  ) external virtual initializer {\n    __LiquidityVault_init(name, symbol, _decimals, _decimalsOffset, _depositableAssets, _redeemableAssets);\n    _grantRole(DEFAULT_ADMIN_ROLE, admin);\n  }\n\n  /// @custom:oz-upgrades-unsafe-allow constructor\n  constructor() {\n    _disableInitializers();\n  }\n\n  /// @inheritdoc IERC165\n  function supportsInterface(bytes4 interfaceId)\n    public\n    view\n    virtual\n    override(AccessControlUpgradeable, ERC165Upgradeable)\n    returns (bool)\n  {\n    return super.supportsInterface(interfaceId) || interfaceId == type(ILiquidityVault).interfaceId\n      || interfaceId == type(IERC165).interfaceId || interfaceId == type(IAccessControl).interfaceId\n      || interfaceId == type(IERC1822Proxiable).interfaceId || interfaceId == type(IERC20).interfaceId\n      || interfaceId == type(IERC20Metadata).interfaceId;\n  }\n\n  /// @inheritdoc UUPSUpgradeable\n  // solhint-disable-next-line no-empty-blocks\n  function _authorizeUpgrade(address newImplementation) internal virtual override onlyRole(DEFAULT_ADMIN_ROLE) {}\n\n  /**\n   * @dev When whitelist is enforced, the sender must have the WHITELIST_ROLE. Otherwise, WHITELIST_ROLE is not required.\n   */\n  modifier checkWhitelistEnforced() {\n    if (_getLiquidityVaultStorage()._whitelistEnforced) {\n      _checkRole(WHITELIST_ROLE, _msgSender());\n    }\n    _;\n  }\n\n  /// @inheritdoc ILiquidityVault\n  function whitelistEnforced() public view virtual override returns (bool) {\n    return _getLiquidityVaultStorage()._whitelistEnforced;\n  }\n\n  /// @inheritdoc ILiquidityVault\n  function setWhitelistEnforced(bool enforced) external virtual override onlyRole(DEFAULT_ADMIN_ROLE) {\n    emit WhitelistEnforced(enforced);\n    _getLiquidityVaultStorage()._whitelistEnforced = enforced;\n  }\n\n  /// @inheritdoc IERC20Metadata\n  function decimals() public view virtual override returns (uint8) {\n    return _getLiquidityVaultStorage()._decimals;\n  }\n\n  /// @inheritdoc ILiquidityVault\n  function decimalsOffset() public view virtual override returns (uint8) {\n    return _getLiquidityVaultStorage()._decimalsOffset;\n  }\n\n  /// @inheritdoc ILiquidityVault\n  function depositableAssets() public view virtual override returns (address[] memory) {\n    return _getLiquidityVaultStorage()._depositableAssets;\n  }\n\n  /// @inheritdoc ILiquidityVault\n  function redeemableAssets() public view virtual override returns (address[] memory) {\n    return _getLiquidityVaultStorage()._redeemableAssets;\n  }\n\n  /**\n   * @dev Updates the assets of the vault\n   * @param asset The address of the asset to update\n   * @param isRedeemable Whether the asset is redeemable\n   * @param add Whether to add the asset or remove the asset\n   */\n  function _updateAssets(address asset, bool isRedeemable, bool add) internal {\n    // Fetch storage\n    LiquidityVaultStorage storage $ = _getLiquidityVaultStorage();\n\n    if (isRedeemable) {\n      if (add) {\n        $._redeemableAssets.push(asset);\n        $._redeemableAssetIndex[asset] = $._redeemableAssets.length;\n      } else {\n        $._redeemableAssets[$._redeemableAssetIndex[asset] - 1] = $._redeemableAssets[$._redeemableAssets.length - 1];\n        $._redeemableAssetIndex[$._redeemableAssets[$._redeemableAssets.length - 1]] = $._redeemableAssetIndex[asset];\n        $._redeemableAssets.pop();\n        $._redeemableAssetIndex[asset] = 0;\n      }\n      emit RedeemableAssetsUpdated($._redeemableAssets);\n    } else {\n      if (add) {\n        $._depositableAssets.push(asset);\n        $._depositableAssetIndex[asset] = $._depositableAssets.length;\n      } else {\n        $._depositableAssets[$._depositableAssetIndex[asset] - 1] =\n          $._depositableAssets[$._depositableAssets.length - 1];\n        $._depositableAssetIndex[$._depositableAssets[$._depositableAssets.length - 1]] =\n          $._depositableAssetIndex[asset];\n        $._depositableAssets.pop();\n        $._depositableAssetIndex[asset] = 0;\n      }\n      emit DepositableAssetsUpdated($._depositableAssets);\n    }\n  }\n\n  /**\n   * @dev Calculates the total assets of the vault\n   * @return The total assets of the vault\n   */\n  function _totalAssets() internal view virtual returns (uint256);\n\n  /// @inheritdoc ILiquidityVault\n  function totalAssets() public view virtual override returns (uint256) {\n    return _totalAssets();\n  }\n\n  /**\n   * @dev Internal conversion function (from assets to shares) with support for rounding direction.\n   * @param assets The amount of assets to convert to shares\n   * @param rounding The rounding direction\n   * @return The amount of shares\n   */\n  function _convertToShares(uint256 assets, Math.Rounding rounding) internal view virtual returns (uint256) {\n    return assets.mulDiv(totalSupply() + 10 ** decimalsOffset(), totalAssets() + 1, rounding);\n  }\n\n  /**\n   * @dev Internal conversion function (from shares to assets) with support for rounding direction.\n   * @param shares The amount of shares to convert to assets\n   * @param rounding The rounding direction\n   * @return The amount of assets\n   */\n  function _convertToAssets(uint256 shares, Math.Rounding rounding) internal view virtual returns (uint256[] memory) {\n    uint256[] memory assets = new uint256[](redeemableAssets().length);\n    for (uint256 i = 0; i < redeemableAssets().length; i++) {\n      assets[i] = shares.mulDiv(\n        IERC20(redeemableAssets()[i]).balanceOf(address(this)) + 1, totalSupply() + 10 ** decimalsOffset(), rounding\n      );\n    }\n    return assets;\n  }\n\n  /// @inheritdoc ILiquidityVault\n  function setPaused(bool paused) external virtual override onlyRole(KEEPER_ROLE) {\n    if (paused) {\n      _pause();\n    } else {\n      _unpause();\n    }\n  }\n\n  /// @inheritdoc ILiquidityVault\n  function deposit(address depositableAsset, uint256 assets)\n    external\n    virtual\n    override\n    whenNotPaused\n    checkWhitelistEnforced\n  {\n    // Validate the depositable asset is in the depositable assets list\n    if (_getLiquidityVaultStorage()._depositableAssetIndex[depositableAsset] == 0) {\n      revert AssetNotDepositable(depositableAsset);\n    }\n    // Calculate the corresponding amount of shares for the deposited amount\n    uint256 shares = _convertToShares(assets, Math.Rounding.Floor);\n    // Mint the corresponding amount of shares to the sender\n    _mint(msg.sender, shares);\n    // Emit the deposited event\n    emit Deposited(msg.sender, depositableAsset, assets, shares);\n    // Transfer the depositable asset from the sender to the vault\n    IERC20(depositableAsset).safeTransferFrom(msg.sender, address(this), assets);\n  }\n\n  /// @inheritdoc ILiquidityVault\n  /// @dev No whitelist enforcement for redeeming. This prevents funds from being locked in the vault.\n  function redeem(uint256 shares) external virtual override whenNotPaused {\n    // Calculate the corresponding amount of assets for the redeemed shares\n    uint256[] memory assetAmounts = _convertToAssets(shares, Math.Rounding.Floor);\n    // Burn the corresponding amount of shares\n    _burn(msg.sender, shares);\n\n    // Cache the redeemable assets array\n    address[] memory rAssets = redeemableAssets();\n\n    // Emit the redeemed event\n    emit Redeemed(msg.sender, rAssets, assetAmounts, shares);\n\n    // Transfer the corresponding amount of redeemable assets to the sender\n    for (uint256 i = 0; i < rAssets.length; i++) {\n      IERC20(rAssets[i]).safeTransfer(msg.sender, assetAmounts[i]);\n    }\n  }\n}\n"},"lib/openzeppelin-contracts/contracts/utils/math/Math.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.3.0) (utils/math/Math.sol)\n\npragma solidity ^0.8.20;\n\nimport {Panic} from \"../Panic.sol\";\nimport {SafeCast} from \"./SafeCast.sol\";\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n    enum Rounding {\n        Floor, // Toward negative infinity\n        Ceil, // Toward positive infinity\n        Trunc, // Toward zero\n        Expand // Away from zero\n    }\n\n    /**\n     * @dev Return the 512-bit addition of two uint256.\n     *\n     * The result is stored in two 256 variables such that sum = high * 2²⁵⁶ + low.\n     */\n    function add512(uint256 a, uint256 b) internal pure returns (uint256 high, uint256 low) {\n        assembly (\"memory-safe\") {\n            low := add(a, b)\n            high := lt(low, a)\n        }\n    }\n\n    /**\n     * @dev Return the 512-bit multiplication of two uint256.\n     *\n     * The result is stored in two 256 variables such that product = high * 2²⁵⁶ + low.\n     */\n    function mul512(uint256 a, uint256 b) internal pure returns (uint256 high, uint256 low) {\n        // 512-bit multiply [high low] = x * y. Compute the product mod 2²⁵⁶ and mod 2²⁵⁶ - 1, then use\n        // the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n        // variables such that product = high * 2²⁵⁶ + low.\n        assembly (\"memory-safe\") {\n            let mm := mulmod(a, b, not(0))\n            low := mul(a, b)\n            high := sub(sub(mm, low), lt(mm, low))\n        }\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, with a success flag (no overflow).\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool success, uint256 result) {\n        unchecked {\n            uint256 c = a + b;\n            success = c >= a;\n            result = c * SafeCast.toUint(success);\n        }\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, with a success flag (no overflow).\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool success, uint256 result) {\n        unchecked {\n            uint256 c = a - b;\n            success = c <= a;\n            result = c * SafeCast.toUint(success);\n        }\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with a success flag (no overflow).\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool success, uint256 result) {\n        unchecked {\n            uint256 c = a * b;\n            assembly (\"memory-safe\") {\n                // Only true when the multiplication doesn't overflow\n                // (c / a == b) || (a == 0)\n                success := or(eq(div(c, a), b), iszero(a))\n            }\n            // equivalent to: success ? c : 0\n            result = c * SafeCast.toUint(success);\n        }\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a success flag (no division by zero).\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool success, uint256 result) {\n        unchecked {\n            success = b > 0;\n            assembly (\"memory-safe\") {\n                // The `DIV` opcode returns zero when the denominator is 0.\n                result := div(a, b)\n            }\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a success flag (no division by zero).\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool success, uint256 result) {\n        unchecked {\n            success = b > 0;\n            assembly (\"memory-safe\") {\n                // The `MOD` opcode returns zero when the denominator is 0.\n                result := mod(a, b)\n            }\n        }\n    }\n\n    /**\n     * @dev Unsigned saturating addition, bounds to `2²⁵⁶ - 1` instead of overflowing.\n     */\n    function saturatingAdd(uint256 a, uint256 b) internal pure returns (uint256) {\n        (bool success, uint256 result) = tryAdd(a, b);\n        return ternary(success, result, type(uint256).max);\n    }\n\n    /**\n     * @dev Unsigned saturating subtraction, bounds to zero instead of overflowing.\n     */\n    function saturatingSub(uint256 a, uint256 b) internal pure returns (uint256) {\n        (, uint256 result) = trySub(a, b);\n        return result;\n    }\n\n    /**\n     * @dev Unsigned saturating multiplication, bounds to `2²⁵⁶ - 1` instead of overflowing.\n     */\n    function saturatingMul(uint256 a, uint256 b) internal pure returns (uint256) {\n        (bool success, uint256 result) = tryMul(a, b);\n        return ternary(success, result, type(uint256).max);\n    }\n\n    /**\n     * @dev Branchless ternary evaluation for `a ? b : c`. Gas costs are constant.\n     *\n     * IMPORTANT: This function may reduce bytecode size and consume less gas when used standalone.\n     * However, the compiler may optimize Solidity ternary operations (i.e. `a ? b : c`) to only compute\n     * one branch when needed, making this function more expensive.\n     */\n    function ternary(bool condition, uint256 a, uint256 b) internal pure returns (uint256) {\n        unchecked {\n            // branchless ternary works because:\n            // b ^ (a ^ b) == a\n            // b ^ 0 == b\n            return b ^ ((a ^ b) * SafeCast.toUint(condition));\n        }\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return ternary(a > b, a, b);\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return ternary(a < b, a, b);\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds towards infinity instead\n     * of rounding towards zero.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (b == 0) {\n            // Guarantee the same behavior as in a regular Solidity division.\n            Panic.panic(Panic.DIVISION_BY_ZERO);\n        }\n\n        // The following calculation ensures accurate ceiling division without overflow.\n        // Since a is non-zero, (a - 1) / b will not overflow.\n        // The largest possible result occurs when (a - 1) / b is type(uint256).max,\n        // but the largest value we can obtain is type(uint256).max - 1, which happens\n        // when a = type(uint256).max and b = 1.\n        unchecked {\n            return SafeCast.toUint(a > 0) * ((a - 1) / b + 1);\n        }\n    }\n\n    /**\n     * @dev Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or\n     * denominator == 0.\n     *\n     * Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv) with further edits by\n     * Uniswap Labs also under MIT license.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            (uint256 high, uint256 low) = mul512(x, y);\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (high == 0) {\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\n                // The surrounding unchecked block does not change this fact.\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\n                return low / denominator;\n            }\n\n            // Make sure the result is less than 2²⁵⁶. Also prevents denominator == 0.\n            if (denominator <= high) {\n                Panic.panic(ternary(denominator == 0, Panic.DIVISION_BY_ZERO, Panic.UNDER_OVERFLOW));\n            }\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [high low].\n            uint256 remainder;\n            assembly (\"memory-safe\") {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                high := sub(high, gt(remainder, low))\n                low := sub(low, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator.\n            // Always >= 1. See https://cs.stackexchange.com/q/138556/92363.\n\n            uint256 twos = denominator & (0 - denominator);\n            assembly (\"memory-safe\") {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [high low] by twos.\n                low := div(low, twos)\n\n                // Flip twos such that it is 2²⁵⁶ / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from high into low.\n            low |= high * twos;\n\n            // Invert denominator mod 2²⁵⁶. Now that denominator is an odd number, it has an inverse modulo 2²⁵⁶ such\n            // that denominator * inv ≡ 1 mod 2²⁵⁶. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv ≡ 1 mod 2⁴.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also\n            // works in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2⁸\n            inverse *= 2 - denominator * inverse; // inverse mod 2¹⁶\n            inverse *= 2 - denominator * inverse; // inverse mod 2³²\n            inverse *= 2 - denominator * inverse; // inverse mod 2⁶⁴\n            inverse *= 2 - denominator * inverse; // inverse mod 2¹²⁸\n            inverse *= 2 - denominator * inverse; // inverse mod 2²⁵⁶\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2²⁵⁶. Since the preconditions guarantee that the outcome is\n            // less than 2²⁵⁶, this is the final result. We don't need to compute the high bits of the result and high\n            // is no longer required.\n            result = low * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @dev Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        return mulDiv(x, y, denominator) + SafeCast.toUint(unsignedRoundsUp(rounding) && mulmod(x, y, denominator) > 0);\n    }\n\n    /**\n     * @dev Calculates floor(x * y >> n) with full precision. Throws if result overflows a uint256.\n     */\n    function mulShr(uint256 x, uint256 y, uint8 n) internal pure returns (uint256 result) {\n        unchecked {\n            (uint256 high, uint256 low) = mul512(x, y);\n            if (high >= 1 << n) {\n                Panic.panic(Panic.UNDER_OVERFLOW);\n            }\n            return (high << (256 - n)) | (low >> n);\n        }\n    }\n\n    /**\n     * @dev Calculates x * y >> n with full precision, following the selected rounding direction.\n     */\n    function mulShr(uint256 x, uint256 y, uint8 n, Rounding rounding) internal pure returns (uint256) {\n        return mulShr(x, y, n) + SafeCast.toUint(unsignedRoundsUp(rounding) && mulmod(x, y, 1 << n) > 0);\n    }\n\n    /**\n     * @dev Calculate the modular multiplicative inverse of a number in Z/nZ.\n     *\n     * If n is a prime, then Z/nZ is a field. In that case all elements are inversible, except 0.\n     * If n is not a prime, then Z/nZ is not a field, and some elements might not be inversible.\n     *\n     * If the input value is not inversible, 0 is returned.\n     *\n     * NOTE: If you know for sure that n is (big) a prime, it may be cheaper to use Fermat's little theorem and get the\n     * inverse using `Math.modExp(a, n - 2, n)`. See {invModPrime}.\n     */\n    function invMod(uint256 a, uint256 n) internal pure returns (uint256) {\n        unchecked {\n            if (n == 0) return 0;\n\n            // The inverse modulo is calculated using the Extended Euclidean Algorithm (iterative version)\n            // Used to compute integers x and y such that: ax + ny = gcd(a, n).\n            // When the gcd is 1, then the inverse of a modulo n exists and it's x.\n            // ax + ny = 1\n            // ax = 1 + (-y)n\n            // ax ≡ 1 (mod n) # x is the inverse of a modulo n\n\n            // If the remainder is 0 the gcd is n right away.\n            uint256 remainder = a % n;\n            uint256 gcd = n;\n\n            // Therefore the initial coefficients are:\n            // ax + ny = gcd(a, n) = n\n            // 0a + 1n = n\n            int256 x = 0;\n            int256 y = 1;\n\n            while (remainder != 0) {\n                uint256 quotient = gcd / remainder;\n\n                (gcd, remainder) = (\n                    // The old remainder is the next gcd to try.\n                    remainder,\n                    // Compute the next remainder.\n                    // Can't overflow given that (a % gcd) * (gcd // (a % gcd)) <= gcd\n                    // where gcd is at most n (capped to type(uint256).max)\n                    gcd - remainder * quotient\n                );\n\n                (x, y) = (\n                    // Increment the coefficient of a.\n                    y,\n                    // Decrement the coefficient of n.\n                    // Can overflow, but the result is casted to uint256 so that the\n                    // next value of y is \"wrapped around\" to a value between 0 and n - 1.\n                    x - y * int256(quotient)\n                );\n            }\n\n            if (gcd != 1) return 0; // No inverse exists.\n            return ternary(x < 0, n - uint256(-x), uint256(x)); // Wrap the result if it's negative.\n        }\n    }\n\n    /**\n     * @dev Variant of {invMod}. More efficient, but only works if `p` is known to be a prime greater than `2`.\n     *\n     * From https://en.wikipedia.org/wiki/Fermat%27s_little_theorem[Fermat's little theorem], we know that if p is\n     * prime, then `a**(p-1) ≡ 1 mod p`. As a consequence, we have `a * a**(p-2) ≡ 1 mod p`, which means that\n     * `a**(p-2)` is the modular multiplicative inverse of a in Fp.\n     *\n     * NOTE: this function does NOT check that `p` is a prime greater than `2`.\n     */\n    function invModPrime(uint256 a, uint256 p) internal view returns (uint256) {\n        unchecked {\n            return Math.modExp(a, p - 2, p);\n        }\n    }\n\n    /**\n     * @dev Returns the modular exponentiation of the specified base, exponent and modulus (b ** e % m)\n     *\n     * Requirements:\n     * - modulus can't be zero\n     * - underlying staticcall to precompile must succeed\n     *\n     * IMPORTANT: The result is only valid if the underlying call succeeds. When using this function, make\n     * sure the chain you're using it on supports the precompiled contract for modular exponentiation\n     * at address 0x05 as specified in https://eips.ethereum.org/EIPS/eip-198[EIP-198]. Otherwise,\n     * the underlying function will succeed given the lack of a revert, but the result may be incorrectly\n     * interpreted as 0.\n     */\n    function modExp(uint256 b, uint256 e, uint256 m) internal view returns (uint256) {\n        (bool success, uint256 result) = tryModExp(b, e, m);\n        if (!success) {\n            Panic.panic(Panic.DIVISION_BY_ZERO);\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the modular exponentiation of the specified base, exponent and modulus (b ** e % m).\n     * It includes a success flag indicating if the operation succeeded. Operation will be marked as failed if trying\n     * to operate modulo 0 or if the underlying precompile reverted.\n     *\n     * IMPORTANT: The result is only valid if the success flag is true. When using this function, make sure the chain\n     * you're using it on supports the precompiled contract for modular exponentiation at address 0x05 as specified in\n     * https://eips.ethereum.org/EIPS/eip-198[EIP-198]. Otherwise, the underlying function will succeed given the lack\n     * of a revert, but the result may be incorrectly interpreted as 0.\n     */\n    function tryModExp(uint256 b, uint256 e, uint256 m) internal view returns (bool success, uint256 result) {\n        if (m == 0) return (false, 0);\n        assembly (\"memory-safe\") {\n            let ptr := mload(0x40)\n            // | Offset    | Content    | Content (Hex)                                                      |\n            // |-----------|------------|--------------------------------------------------------------------|\n            // | 0x00:0x1f | size of b  | 0x0000000000000000000000000000000000000000000000000000000000000020 |\n            // | 0x20:0x3f | size of e  | 0x0000000000000000000000000000000000000000000000000000000000000020 |\n            // | 0x40:0x5f | size of m  | 0x0000000000000000000000000000000000000000000000000000000000000020 |\n            // | 0x60:0x7f | value of b | 0x<.............................................................b> |\n            // | 0x80:0x9f | value of e | 0x<.............................................................e> |\n            // | 0xa0:0xbf | value of m | 0x<.............................................................m> |\n            mstore(ptr, 0x20)\n            mstore(add(ptr, 0x20), 0x20)\n            mstore(add(ptr, 0x40), 0x20)\n            mstore(add(ptr, 0x60), b)\n            mstore(add(ptr, 0x80), e)\n            mstore(add(ptr, 0xa0), m)\n\n            // Given the result < m, it's guaranteed to fit in 32 bytes,\n            // so we can use the memory scratch space located at offset 0.\n            success := staticcall(gas(), 0x05, ptr, 0xc0, 0x00, 0x20)\n            result := mload(0x00)\n        }\n    }\n\n    /**\n     * @dev Variant of {modExp} that supports inputs of arbitrary length.\n     */\n    function modExp(bytes memory b, bytes memory e, bytes memory m) internal view returns (bytes memory) {\n        (bool success, bytes memory result) = tryModExp(b, e, m);\n        if (!success) {\n            Panic.panic(Panic.DIVISION_BY_ZERO);\n        }\n        return result;\n    }\n\n    /**\n     * @dev Variant of {tryModExp} that supports inputs of arbitrary length.\n     */\n    function tryModExp(\n        bytes memory b,\n        bytes memory e,\n        bytes memory m\n    ) internal view returns (bool success, bytes memory result) {\n        if (_zeroBytes(m)) return (false, new bytes(0));\n\n        uint256 mLen = m.length;\n\n        // Encode call args in result and move the free memory pointer\n        result = abi.encodePacked(b.length, e.length, mLen, b, e, m);\n\n        assembly (\"memory-safe\") {\n            let dataPtr := add(result, 0x20)\n            // Write result on top of args to avoid allocating extra memory.\n            success := staticcall(gas(), 0x05, dataPtr, mload(result), dataPtr, mLen)\n            // Overwrite the length.\n            // result.length > returndatasize() is guaranteed because returndatasize() == m.length\n            mstore(result, mLen)\n            // Set the memory pointer after the returned data.\n            mstore(0x40, add(dataPtr, mLen))\n        }\n    }\n\n    /**\n     * @dev Returns whether the provided byte array is zero.\n     */\n    function _zeroBytes(bytes memory byteArray) private pure returns (bool) {\n        for (uint256 i = 0; i < byteArray.length; ++i) {\n            if (byteArray[i] != 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded\n     * towards zero.\n     *\n     * This method is based on Newton's method for computing square roots; the algorithm is restricted to only\n     * using integer operations.\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        unchecked {\n            // Take care of easy edge cases when a == 0 or a == 1\n            if (a <= 1) {\n                return a;\n            }\n\n            // In this function, we use Newton's method to get a root of `f(x) := x² - a`. It involves building a\n            // sequence x_n that converges toward sqrt(a). For each iteration x_n, we also define the error between\n            // the current value as `ε_n = | x_n - sqrt(a) |`.\n            //\n            // For our first estimation, we consider `e` the smallest power of 2 which is bigger than the square root\n            // of the target. (i.e. `2**(e-1) ≤ sqrt(a) < 2**e`). We know that `e ≤ 128` because `(2¹²⁸)² = 2²⁵⁶` is\n            // bigger than any uint256.\n            //\n            // By noticing that\n            // `2**(e-1) ≤ sqrt(a) < 2**e → (2**(e-1))² ≤ a < (2**e)² → 2**(2*e-2) ≤ a < 2**(2*e)`\n            // we can deduce that `e - 1` is `log2(a) / 2`. We can thus compute `x_n = 2**(e-1)` using a method similar\n            // to the msb function.\n            uint256 aa = a;\n            uint256 xn = 1;\n\n            if (aa >= (1 << 128)) {\n                aa >>= 128;\n                xn <<= 64;\n            }\n            if (aa >= (1 << 64)) {\n                aa >>= 64;\n                xn <<= 32;\n            }\n            if (aa >= (1 << 32)) {\n                aa >>= 32;\n                xn <<= 16;\n            }\n            if (aa >= (1 << 16)) {\n                aa >>= 16;\n                xn <<= 8;\n            }\n            if (aa >= (1 << 8)) {\n                aa >>= 8;\n                xn <<= 4;\n            }\n            if (aa >= (1 << 4)) {\n                aa >>= 4;\n                xn <<= 2;\n            }\n            if (aa >= (1 << 2)) {\n                xn <<= 1;\n            }\n\n            // We now have x_n such that `x_n = 2**(e-1) ≤ sqrt(a) < 2**e = 2 * x_n`. This implies ε_n ≤ 2**(e-1).\n            //\n            // We can refine our estimation by noticing that the middle of that interval minimizes the error.\n            // If we move x_n to equal 2**(e-1) + 2**(e-2), then we reduce the error to ε_n ≤ 2**(e-2).\n            // This is going to be our x_0 (and ε_0)\n            xn = (3 * xn) >> 1; // ε_0 := | x_0 - sqrt(a) | ≤ 2**(e-2)\n\n            // From here, Newton's method give us:\n            // x_{n+1} = (x_n + a / x_n) / 2\n            //\n            // One should note that:\n            // x_{n+1}² - a = ((x_n + a / x_n) / 2)² - a\n            //              = ((x_n² + a) / (2 * x_n))² - a\n            //              = (x_n⁴ + 2 * a * x_n² + a²) / (4 * x_n²) - a\n            //              = (x_n⁴ + 2 * a * x_n² + a² - 4 * a * x_n²) / (4 * x_n²)\n            //              = (x_n⁴ - 2 * a * x_n² + a²) / (4 * x_n²)\n            //              = (x_n² - a)² / (2 * x_n)²\n            //              = ((x_n² - a) / (2 * x_n))²\n            //              ≥ 0\n            // Which proves that for all n ≥ 1, sqrt(a) ≤ x_n\n            //\n            // This gives us the proof of quadratic convergence of the sequence:\n            // ε_{n+1} = | x_{n+1} - sqrt(a) |\n            //         = | (x_n + a / x_n) / 2 - sqrt(a) |\n            //         = | (x_n² + a - 2*x_n*sqrt(a)) / (2 * x_n) |\n            //         = | (x_n - sqrt(a))² / (2 * x_n) |\n            //         = | ε_n² / (2 * x_n) |\n            //         = ε_n² / | (2 * x_n) |\n            //\n            // For the first iteration, we have a special case where x_0 is known:\n            // ε_1 = ε_0² / | (2 * x_0) |\n            //     ≤ (2**(e-2))² / (2 * (2**(e-1) + 2**(e-2)))\n            //     ≤ 2**(2*e-4) / (3 * 2**(e-1))\n            //     ≤ 2**(e-3) / 3\n            //     ≤ 2**(e-3-log2(3))\n            //     ≤ 2**(e-4.5)\n            //\n            // For the following iterations, we use the fact that, 2**(e-1) ≤ sqrt(a) ≤ x_n:\n            // ε_{n+1} = ε_n² / | (2 * x_n) |\n            //         ≤ (2**(e-k))² / (2 * 2**(e-1))\n            //         ≤ 2**(2*e-2*k) / 2**e\n            //         ≤ 2**(e-2*k)\n            xn = (xn + a / xn) >> 1; // ε_1 := | x_1 - sqrt(a) | ≤ 2**(e-4.5)  -- special case, see above\n            xn = (xn + a / xn) >> 1; // ε_2 := | x_2 - sqrt(a) | ≤ 2**(e-9)    -- general case with k = 4.5\n            xn = (xn + a / xn) >> 1; // ε_3 := | x_3 - sqrt(a) | ≤ 2**(e-18)   -- general case with k = 9\n            xn = (xn + a / xn) >> 1; // ε_4 := | x_4 - sqrt(a) | ≤ 2**(e-36)   -- general case with k = 18\n            xn = (xn + a / xn) >> 1; // ε_5 := | x_5 - sqrt(a) | ≤ 2**(e-72)   -- general case with k = 36\n            xn = (xn + a / xn) >> 1; // ε_6 := | x_6 - sqrt(a) | ≤ 2**(e-144)  -- general case with k = 72\n\n            // Because e ≤ 128 (as discussed during the first estimation phase), we know have reached a precision\n            // ε_6 ≤ 2**(e-144) < 1. Given we're operating on integers, then we can ensure that xn is now either\n            // sqrt(a) or sqrt(a) + 1.\n            return xn - SafeCast.toUint(xn > a / xn);\n        }\n    }\n\n    /**\n     * @dev Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + SafeCast.toUint(unsignedRoundsUp(rounding) && result * result < a);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 x) internal pure returns (uint256 r) {\n        // If value has upper 128 bits set, log2 result is at least 128\n        r = SafeCast.toUint(x > 0xffffffffffffffffffffffffffffffff) << 7;\n        // If upper 64 bits of 128-bit half set, add 64 to result\n        r |= SafeCast.toUint((x >> r) > 0xffffffffffffffff) << 6;\n        // If upper 32 bits of 64-bit half set, add 32 to result\n        r |= SafeCast.toUint((x >> r) > 0xffffffff) << 5;\n        // If upper 16 bits of 32-bit half set, add 16 to result\n        r |= SafeCast.toUint((x >> r) > 0xffff) << 4;\n        // If upper 8 bits of 16-bit half set, add 8 to result\n        r |= SafeCast.toUint((x >> r) > 0xff) << 3;\n        // If upper 4 bits of 8-bit half set, add 4 to result\n        r |= SafeCast.toUint((x >> r) > 0xf) << 2;\n\n        // Shifts value right by the current result and use it as an index into this lookup table:\n        //\n        // | x (4 bits) |  index  | table[index] = MSB position |\n        // |------------|---------|-----------------------------|\n        // |    0000    |    0    |        table[0] = 0         |\n        // |    0001    |    1    |        table[1] = 0         |\n        // |    0010    |    2    |        table[2] = 1         |\n        // |    0011    |    3    |        table[3] = 1         |\n        // |    0100    |    4    |        table[4] = 2         |\n        // |    0101    |    5    |        table[5] = 2         |\n        // |    0110    |    6    |        table[6] = 2         |\n        // |    0111    |    7    |        table[7] = 2         |\n        // |    1000    |    8    |        table[8] = 3         |\n        // |    1001    |    9    |        table[9] = 3         |\n        // |    1010    |   10    |        table[10] = 3        |\n        // |    1011    |   11    |        table[11] = 3        |\n        // |    1100    |   12    |        table[12] = 3        |\n        // |    1101    |   13    |        table[13] = 3        |\n        // |    1110    |   14    |        table[14] = 3        |\n        // |    1111    |   15    |        table[15] = 3        |\n        //\n        // The lookup table is represented as a 32-byte value with the MSB positions for 0-15 in the last 16 bytes.\n        assembly (\"memory-safe\") {\n            r := or(r, byte(shr(r, x), 0x0000010102020202030303030303030300000000000000000000000000000000))\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + SafeCast.toUint(unsignedRoundsUp(rounding) && 1 << result < value);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 10 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + SafeCast.toUint(unsignedRoundsUp(rounding) && 10 ** result < value);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 256 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     *\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\n     */\n    function log256(uint256 x) internal pure returns (uint256 r) {\n        // If value has upper 128 bits set, log2 result is at least 128\n        r = SafeCast.toUint(x > 0xffffffffffffffffffffffffffffffff) << 7;\n        // If upper 64 bits of 128-bit half set, add 64 to result\n        r |= SafeCast.toUint((x >> r) > 0xffffffffffffffff) << 6;\n        // If upper 32 bits of 64-bit half set, add 32 to result\n        r |= SafeCast.toUint((x >> r) > 0xffffffff) << 5;\n        // If upper 16 bits of 32-bit half set, add 16 to result\n        r |= SafeCast.toUint((x >> r) > 0xffff) << 4;\n        // Add 1 if upper 8 bits of 16-bit half set, and divide accumulated result by 8\n        return (r >> 3) | SafeCast.toUint((x >> r) > 0xff);\n    }\n\n    /**\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + SafeCast.toUint(unsignedRoundsUp(rounding) && 1 << (result << 3) < value);\n        }\n    }\n\n    /**\n     * @dev Returns whether a provided rounding mode is considered rounding up for unsigned integers.\n     */\n    function unsignedRoundsUp(Rounding rounding) internal pure returns (bool) {\n        return uint8(rounding) % 2 == 1;\n    }\n}\n"},"lib/openzeppelin-contracts/contracts/token/ERC20/IERC20.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (token/ERC20/IERC20.sol)\n\npragma solidity >=0.4.16;\n\n/**\n * @dev Interface of the ERC-20 standard as defined in the ERC.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the value of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the value of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 value) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\n     * caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 value) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the\n     * allowance mechanism. `value` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\n}\n"},"lib/cash/src/interfaces/IGeneralManager/IGeneralManager.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.20;\n\nimport {IGeneralManagerEvents} from \"./IGeneralManagerEvents.sol\";\nimport {IGeneralManagerErrors} from \"./IGeneralManagerErrors.sol\";\nimport {MortgagePosition} from \"../../types/MortgagePosition.sol\";\nimport {CreationRequest, ExpansionRequest} from \"../../types/orders/OrderRequests.sol\";\nimport {IOriginationPoolDeployCallback} from \"../IOriginationPoolDeployCallback.sol\";\nimport {OriginationParameters} from \"../../types/orders/OriginationParameters.sol\";\nimport {IPausable} from \"../IPausable/IPausable.sol\";\n\n/**\n * @title IGeneralManager\n * @author @SocksNFlops\n * @notice The GeneralManager contract is responsible for managing the mortgage positions and the foreclosure process.\n */\ninterface IGeneralManager is IOriginationPoolDeployCallback, IPausable, IGeneralManagerEvents, IGeneralManagerErrors {\n  /**\n   * @notice Returns the USDX token address\n   * @return The USDX token address\n   */\n  function usdx() external view returns (address);\n\n  /**\n   * @notice Returns the Consol token address\n   * @return The Consol token address\n   */\n  function consol() external view returns (address);\n\n  /**\n   * @notice Sets the penalty rate for a mortgage (in basis points)\n   * @param penaltyRate_ The penalty rate\n   */\n  function setPenaltyRate(uint16 penaltyRate_) external;\n\n  /**\n   * @notice Returns the penalty rate for a mortgage (in basis points)\n   * @dev Takes in a mortgage position to allow upgraded implementations to take into account the position's details.\n   * @param mortgagePosition The position of the mortgage\n   * @return The penalty rate\n   */\n  function penaltyRate(MortgagePosition memory mortgagePosition) external view returns (uint16);\n\n  /**\n   * @notice Sets the refinance rate for a mortgage (in basis points)\n   * @param refinanceRate_ The refinance rate\n   */\n  function setRefinanceRate(uint16 refinanceRate_) external;\n\n  /**\n   * @notice Returns the refinance rate (in basis points).\n   * @dev Takes in a mortgage position to allow upgraded implementations to take into account the position's details.\n   * @param mortgagePosition The position of the mortgage\n   * @return The refinance rate\n   */\n  function refinanceRate(MortgagePosition memory mortgagePosition) external view returns (uint16);\n\n  /**\n   * @notice Sets the insurance fund address\n   * @param insuranceFund_ The insurance fund address\n   */\n  function setInsuranceFund(address insuranceFund_) external;\n\n  /**\n   * @notice Returns the insurance fund address\n   * @return The insurance fund address\n   */\n  function insuranceFund() external view returns (address);\n\n  /**\n   * @notice Returns the interest rate oracle address\n   * @return The interest rate oracle address\n   */\n  function interestRateOracle() external view returns (address);\n\n  /**\n   * @notice Sets the interest rate oracle address\n   * @param interestRateOracle_ The interest rate oracle address\n   */\n  function setInterestRateOracle(address interestRateOracle_) external;\n\n  /**\n   * @notice Returns the interest rate (in basis points)\n   * @param collateral The address of the collateral\n   * @param totalPeriods The total number of periods for the mortgage\n   * @param hasPaymentPlan Whether the mortgage has a payment plan\n   * @return The interest rate\n   */\n  function interestRate(address collateral, uint8 totalPeriods, bool hasPaymentPlan) external view returns (uint16);\n\n  /**\n   * @notice Returns the conversion premium rate (in basis points)\n   * @param collateral The address of the collateral\n   * @param totalPeriods The total number of periods for the mortgage\n   * @param hasPaymentPlan Whether the mortgage has a payment plan\n   * @return The conversion premium rate\n   */\n  function conversionPremiumRate(address collateral, uint8 totalPeriods, bool hasPaymentPlan)\n    external\n    view\n    returns (uint16);\n\n  /**\n   * @notice Sets the conversion premium rate (in basis points)\n   * @param conversionPremiumRate_ The conversion premium rate\n   */\n  function setConversionPremiumRate(uint16 conversionPremiumRate_) external;\n\n  /**\n   * @notice Sets the origination pool scheduler address\n   * @param originationPoolScheduler_ The origination pool scheduler address\n   */\n  function setOriginationPoolScheduler(address originationPoolScheduler_) external;\n\n  /**\n   * @notice Returns the origination pool scheduler address\n   * @return The origination pool scheduler address\n   */\n  function originationPoolScheduler() external view returns (address);\n\n  /**\n   * @notice Sets the loan manager address\n   * @param loanManager_ The loan manager address\n   */\n  function setLoanManager(address loanManager_) external;\n\n  /**\n   * @notice Returns the loan manager address\n   * @return The loan manager address\n   */\n  function loanManager() external view returns (address);\n\n  /**\n   * @notice Returns the mortgage NFT address\n   * @return The mortgage NFT address\n   */\n  function mortgageNFT() external view returns (address);\n\n  /**\n   * @notice Sets the order pool address\n   * @param orderPool_ The order pool address\n   */\n  function setOrderPool(address orderPool_) external;\n\n  /**\n   * @notice Returns the order pool address\n   * @return The order pool address\n   */\n  function orderPool() external view returns (address);\n\n  /**\n   * @notice Updates the supported mortgage period terms for a collateral.\n   * @param collateral The address of the collateral\n   * @param totalPeriods The new total number of periods for the new mortgage term\n   * @param isSupported Whether the mortgage period term is supported\n   */\n  function updateSupportedMortgagePeriodTerms(address collateral, uint8 totalPeriods, bool isSupported) external;\n\n  /**\n   * @notice Returns whether a mortgage period term is supported\n   * @param collateral The address of the collateral\n   * @param mortgagePeriods The mortgage period\n   * @return Whether the mortgage period term is supported\n   */\n  function isSupportedMortgagePeriodTerms(address collateral, uint8 mortgagePeriods) external view returns (bool);\n\n  /**\n   * @notice The address of the price oracle for the collateral\n   * @param collateral The address of the collateral\n   * @return The address of the price oracle\n   */\n  function priceOracles(address collateral) external view returns (address);\n\n  /**\n   * @notice Sets the address of the price oracle\n   * @param collateral The address of the collateral\n   * @param priceOracle The address of the price oracle\n   */\n  function setPriceOracle(address collateral, address priceOracle) external;\n\n  /**\n   * @notice Returns the minimum request size of a mortgage for a given collateral. Requests cannot borrow less than this amount.\n   * @param collateral The address of the collateral\n   * @return The minimum cap\n   */\n  function minimumCap(address collateral) external view returns (uint256);\n\n  /**\n   * @notice Sets the minimum request size of a mortgage for a given collateral. Requests cannot borrow less than this amount.\n   * @param collateral The address of the collateral\n   * @param minimumCap_ The minimum cap\n   */\n  function setMinimumCap(address collateral, uint256 minimumCap_) external;\n\n  /**\n   * @notice Returns the maximum request size of a mortgage for a given collateral. Requests cannot borrow more than this amount.\n   * @param collateral The address of the collateral\n   * @return The maximum cap\n   */\n  function maximumCap(address collateral) external view returns (uint256);\n\n  /**\n   * @notice Sets the maximum request size of a mortgage for a given collateral. Requests cannot borrow more than this amount.\n   * @param collateral The address of the collateral\n   * @param maximumCap_ The maximum cap\n   */\n  function setMaximumCap(address collateral, uint256 maximumCap_) external;\n\n  /**\n   * @notice The price spread to incentivize the fulfiller to fill orders\n   * @return priceSpread The price spread\n   */\n  function priceSpread() external view returns (uint16);\n\n  /**\n   * @notice Sets the price spread to incentivize the fulfiller to fill orders\n   * @param priceSpread_ The price spread\n   */\n  function setPriceSpread(uint16 priceSpread_) external;\n\n  /**\n   * @notice Returns the conversion queues a given mortgage position is registered with\n   * @param tokenId The tokenId of the mortgage position\n   * @return The conversion queues\n   */\n  function conversionQueues(uint256 tokenId) external view returns (address[] memory);\n\n  /**\n   * @notice Requests a new mortgage creation\n   * @param creationRequest The parameters of the mortgage creation being requested\n   * @return tokenId The tokenId of the mortgage NFT that was created\n   */\n  function requestMortgageCreation(CreationRequest calldata creationRequest) external payable returns (uint256 tokenId);\n\n  /**\n   * @notice Burns a mortgage NFT\n   * @param tokenId The tokenId of the mortgage NFT to burn\n   */\n  function burnMortgageNFT(uint256 tokenId) external;\n\n  /**\n   * @notice Originates a mortgage position. Only callable by the OrderPool.\n   * @param originationParameters The parameters for originating a mortgage creation or balance sheet expansion\n   */\n  function originate(OriginationParameters calldata originationParameters) external payable;\n\n  /**\n   * @notice Enqueues a mortgage position into a conversion queue\n   * @param tokenId The tokenId of the mortgage position\n   * @param conversionQueueList The list of conversion queues to use\n   * @param hintPrevIds The hint for the previous mortgage position in the conversion queue\n   */\n  function enqueueMortgage(uint256 tokenId, address[] memory conversionQueueList, uint256[] memory hintPrevIds)\n    external\n    payable;\n\n  /**\n   * @notice Converts a mortgage position\n   * @param tokenId The tokenId of the mortgage position\n   * @param amount The amount of the principal being coverted\n   * @param collateralAmount The amount of the collateral being withdrawn during the conversion\n   * @param receiver The address receiving the converted collateral\n   */\n  function convert(uint256 tokenId, uint256 amount, uint256 collateralAmount, address receiver) external;\n\n  /**\n   * @notice Requests to expand the balance sheet of a mortgage position by adding additional principal and collateral to the mortgage position. Only callable by whitelisted addresses.\n   * @param expansionRequest The parameters of the balance sheet expansion being requested\n   */\n  function requestBalanceSheetExpansion(ExpansionRequest calldata expansionRequest) external payable;\n}\n"},"lib/cash/src/interfaces/IOriginationPool/IOriginationPool.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.20;\n\nimport {IOriginationPoolEvents} from \"./IOriginationPoolEvents.sol\";\nimport {IOriginationPoolErrors} from \"./IOriginationPoolErrors.sol\";\nimport {IPausable} from \"../IPausable/IPausable.sol\";\nimport {OriginationPoolPhase} from \"../../types/enums/OriginationPoolPhase.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\n/**\n * @title Interface for the OriginationPool contract\n */\ninterface IOriginationPool is IOriginationPoolEvents, IOriginationPoolErrors, IPausable, IERC20 {\n  /**\n   * @notice The USDX token address\n   * @return The usdx address\n   */\n  function usdx() external view returns (address);\n\n  /**\n   * @notice The Consol token address\n   * @return The consol address\n   */\n  function consol() external view returns (address);\n\n  /**\n   * @notice The deposit phase timestamp\n   * @return The deposit phase timestamp\n   */\n  function depositPhaseTimestamp() external view returns (uint256);\n\n  /**\n   * @notice The deploy phase timestamp\n   * @return The deploy phase timestamp\n   */\n  function deployPhaseTimestamp() external view returns (uint256);\n\n  /**\n   * @notice The redemption phase timestamp\n   * @return The redemption phase timestamp\n   */\n  function redemptionPhaseTimestamp() external view returns (uint256);\n\n  /**\n   * @notice Fetches the current phase of the Origination Pool\n   * @return The current phase\n   */\n  function currentPhase() external view returns (OriginationPoolPhase);\n\n  /**\n   * @notice Fetches the pool multiplier in basis points\n   * @return The pool multiplier in basis points\n   */\n  function poolMultiplierBps() external view returns (uint16);\n\n  /**\n   * @notice Fetches the pool deposit limit\n   * @return The pool deposit limit\n   */\n  function poolLimit() external view returns (uint256);\n\n  /**\n   * @notice Fetches the amount of USD tokens deployed from the pool\n   * @return The amount of USD tokens deployed from the pool\n   */\n  function amountDeployed() external view returns (uint256);\n\n  /**\n   * @notice Calculates the return amount of Consol for a given amount of USDX by applying the pool multiplier\n   * @param amount The amount of USDX to calculate the return amount for\n   * @return returnAmount The return amount of Consol\n   */\n  function calculateReturnAmount(uint256 amount) external view returns (uint256 returnAmount);\n\n  /**\n   * @notice Deposit USDX into the pool\n   * @param amount The amount of USDX to deposit\n   * @return mintAmount The amount of receipt tokens minted to the user\n   */\n  function deposit(uint256 amount) external returns (uint256 mintAmount);\n\n  /**\n   * @notice Redeem USDX + Consol from the pool from receipt tokens\n   * @param amount The amount of receipt tokens to burn in exchange for USDX + Consol\n   */\n  function redeem(uint256 amount) external;\n\n  /**\n   * @notice Deploy USDX in the pool and convert it to Consol. Only callable by contracts implementing IOriginationPoolDeployCallback\n   * @param amount The amount of USDX to deploy\n   * @param data The calldata to pass into the callback\n   */\n  function deploy(uint256 amount, bytes calldata data) external;\n}\n"},"lib/cash/src/interfaces/IOriginationPoolScheduler/IOriginationPoolScheduler.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.20;\n\nimport {IOriginationPoolSchedulerEvents} from \"./IOriginationPoolSchedulerEvents.sol\";\nimport {IOriginationPoolSchedulerErrors} from \"./IOriginationPoolSchedulerErrors.sol\";\nimport {OriginationPoolConfig} from \"../../types/OriginationPoolConfig.sol\";\nimport {OPoolConfigId} from \"../../types/OPoolConfigId.sol\";\nimport {IPausable} from \"../IPausable/IPausable.sol\";\n\n/**\n * @notice A record of the last deployment address, epoch, and timestamp for a given origination pool config\n * @param deploymentAddress The address of the last deployment\n * @param epoch The epoch number of the last deployment\n * @param timestamp The timestamp of the last deployment\n */\nstruct LastDeploymentRecord {\n  address deploymentAddress;\n  uint256 epoch;\n  uint256 timestamp;\n}\n\n/**\n * @title Interface for the OriginationPoolFactory contract\n * @author SocksNFlops\n * @notice Interface for the OriginationPoolFactory contract\n */\ninterface IOriginationPoolScheduler is IOriginationPoolSchedulerEvents, IOriginationPoolSchedulerErrors, IPausable {\n  /**\n   * @notice Set the general manager address\n   * @param newGeneralManager The address of the new general manager\n   */\n  function setGeneralManager(address newGeneralManager) external;\n\n  /**\n   * @notice Get the general manager address\n   * @return The address of the general manager\n   */\n  function generalManager() external view returns (address);\n\n  /**\n   * @notice Set the admin address that is assigned to the origination pools on deployment\n   * @param newOpoolAdmin The address of the new origination pool admin\n   */\n  function setOpoolAdmin(address newOpoolAdmin) external;\n\n  /**\n   * @notice Get the admin address that is assigned to the origination pools on deployment\n   * @return The address of the origination pool admin\n   */\n  function oPoolAdmin() external view returns (address);\n\n  /**\n   * @notice Get the number of origination pool configs\n   * @return The number of origination pool configs\n   */\n  function configLength() external view returns (uint256);\n\n  /**\n   * @notice Get the origination pool config ID at the given index\n   * @param index The index of the origination pool config to get the ID for\n   * @return oPoolConfigId The ID of the origination pool config\n   */\n  function configIdAt(uint256 index) external view returns (OPoolConfigId oPoolConfigId);\n\n  /**\n   * @notice Get the origination pool config at the given index\n   * @param index The index of the origination pool config to get\n   * @return config The origination pool config\n   */\n  function configAt(uint256 index) external view returns (OriginationPoolConfig memory);\n\n  /**\n   * @notice Get the last deployment address from the given config index\n   * @param index The index of the origination pool config to get the last deployment address from\n   * @return lastDeploymentRecord The last deployment record\n   */\n  function lastConfigDeployment(uint256 index) external view returns (LastDeploymentRecord memory lastDeploymentRecord);\n\n  /**\n   * @notice Get the last deployment address from the given config ID\n   * @param oPoolConfigId The ID of the origination pool config to get the last deployment address from\n   * @return lastDeploymentRecord The last deployment record\n   */\n  function lastConfigDeployment(OPoolConfigId oPoolConfigId)\n    external\n    view\n    returns (LastDeploymentRecord memory lastDeploymentRecord);\n\n  /**\n   * @notice Add a new origination pool config\n   * @param config The origination pool config to add\n   */\n  function addConfig(OriginationPoolConfig memory config) external;\n\n  /**\n   * @notice Remove an origination pool config\n   * @param config The origination pool config to remove\n   */\n  function removeConfig(OriginationPoolConfig memory config) external;\n\n  /**\n   * @notice Get the current epoch. Indexed from 1\n   * @return currentEpoch The current epoch\n   */\n  function currentEpoch() external view returns (uint256);\n\n  /**\n   * @notice Deploy a new origination pool\n   * @param oPoolConfigId The ID of the origination pool config to deploy\n   * @return deploymentAddress The address of the deployed origination pool\n   */\n  function deployOriginationPool(OPoolConfigId oPoolConfigId) external returns (address deploymentAddress);\n\n  /**\n   * @notice Predict the origination pool address for the given config ID and current epoch. If already deployed, will return the already deployed address.\n   * @param oPoolConfigId The ID of the origination pool config to predict the address for\n   * @return deploymentAddress The predicted deployment address\n   */\n  function predictOriginationPool(OPoolConfigId oPoolConfigId) external view returns (address deploymentAddress);\n\n  /**\n   * @notice Check if an origination pool is registered (deployed by the scheduler)\n   * @param originationPool The address of the origination pool to check\n   * @return registered Whether the origination pool is registered\n   */\n  function isRegistered(address originationPool) external view returns (bool registered);\n\n  /**\n   * @notice Update the registration of an origination pool\n   * @param originationPool The address of the origination pool to update the registration for\n   * @param registered Whether the origination pool is registered\n   */\n  function updateRegistration(address originationPool, bool registered) external;\n}\n"},"src/interfaces/ILiquidityVault/ILiquidityVault.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.20;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {ILiquidityVaultEvents} from \"./ILiquidityVaultEvents.sol\";\nimport {ILiquidityVaultErrors} from \"./ILiquidityVaultErrors.sol\";\n\n/**\n * @title ILiquidityVault\n * @author @SocksNFlops\n * @notice Interface for LiquidityVault, a yield-bearing vault that enables depositing tokens for redeemable shares that earn yield.\n */\ninterface ILiquidityVault is IERC20, ILiquidityVaultEvents, ILiquidityVaultErrors {\n  /**\n   * @notice The role for the keeper\n   * @return The role for the keeper\n   */\n  // solhint-disable-next-line func-name-mixedcase\n  function KEEPER_ROLE() external view returns (bytes32);\n\n  /**\n   * @notice\n   * @return The role for the whitelist\n   */\n  // solhint-disable-next-line func-name-mixedcase\n  function WHITELIST_ROLE() external view returns (bytes32);\n\n  /**\n   * @notice Whether the whitelist is enforced.\n   * @return Whether the whitelist is enforced.\n   */\n  function whitelistEnforced() external view returns (bool);\n\n  /**\n   * @notice Enforces the whitelist.\n   * @param enforced Whether the whitelist is enforced.\n   */\n  function setWhitelistEnforced(bool enforced) external;\n\n  /**\n   * @notice The decimals offset. The number of decimals to offset the shares by. Used to protect against inflation attacks.\n   * @return The decimals offset\n   */\n  function decimalsOffset() external view returns (uint8);\n\n  /**\n   * @notice The total assets of the vault\n   * @return The total assets of the vault\n   */\n  function totalAssets() external view returns (uint256);\n\n  /**\n   * @notice The address of the depositable asset.\n   * @return The address of the depositable asset.\n   */\n  function depositableAssets() external view returns (address[] memory);\n\n  /**\n   * @notice The addresses of the redeemable assets.\n   * @return The addresses of the redeemable assets.\n   */\n  function redeemableAssets() external view returns (address[] memory);\n\n  /**\n   * @notice Sets the paused state of the vault.\n   * @param paused The paused state of the vault.\n   */\n  function setPaused(bool paused) external;\n\n  /**\n   * @notice Deposits the specified amount of depositable asset into the vault.\n   * @param depositableAsset The address of the depositable asset to deposit.\n   * @param assets The amount of depositable asset to deposit.\n   */\n  function deposit(address depositableAsset, uint256 assets) external;\n\n  /**\n   * @notice Redeems the specified amount of shares for the redeemable asset.\n   * @param shares The amount of shares to redeem.\n   */\n  function redeem(uint256 shares) external;\n}\n"},"src/interfaces/IRolloverVault/IRolloverVaultEvents.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.20;\n\n/**\n * @title IRolloverVaultEvents\n * @author @SocksNFlops\n * @notice Interface for events emitted by RolloverVaults.\n */\ninterface IRolloverVaultEvents {\n  /**\n   * @notice Emitted when an origination pool is added to the rollover vault\n   * @param originationPool The address of the origination pool that was added\n   */\n  event OriginationPoolAdded(address originationPool);\n\n  /**\n   * @notice Emitted when USDX is deposited into an origination pool\n   * @param originationPool The address of the origination pool that was deposited into\n   * @param amount The amount of USDX that was deposited into the origination pool\n   */\n  event OriginationPoolDeposited(address originationPool, uint256 amount);\n\n  /**\n   * @notice Emitted when USDX is redeemed from an origination pool\n   * @param originationPool The address of the origination pool that was redeemed from\n   * @param amount The amount of receipt tokens that was redeemed from the origination pool\n   */\n  event OriginationPoolRedeemed(address originationPool, uint256 amount);\n}\n"},"src/interfaces/IRolloverVault/IRolloverVaultErrors.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.20;\n\n/**\n * @title IRolloverVaultErrors\n * @author @SocksNFlops\n * @notice Interface for errors emitted by RolloverVaults.\n */\ninterface IRolloverVaultErrors {\n  /**\n   * @notice Thrown when an origination pool is not registered\n   * @param originationPool The address of the origination pool that is not registered\n   */\n  error OriginationPoolNotRegistered(address originationPool);\n\n  /**\n   * @notice Thrown when an amount is zero\n   */\n  error AmountIsZero();\n\n  /**\n   * @notice Thrown when an origination pool is not being tracked by the rollover vault\n   * @param originationPool The address of the origination pool that is not being tracked\n   */\n  error OriginationPoolNotTracked(address originationPool);\n}\n"},"lib/openzeppelin-contracts-upgradeable/contracts/token/ERC20/ERC20Upgradeable.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (token/ERC20/ERC20.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {IERC20Metadata} from \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport {ContextUpgradeable} from \"../../utils/ContextUpgradeable.sol\";\nimport {IERC20Errors} from \"@openzeppelin/contracts/interfaces/draft-IERC6093.sol\";\nimport {Initializable} from \"../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.openzeppelin.com/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * The default value of {decimals} is 18. To change this, you should override\n * this function so it returns a different value.\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC-20\n * applications.\n */\nabstract contract ERC20Upgradeable is Initializable, ContextUpgradeable, IERC20, IERC20Metadata, IERC20Errors {\n    /// @custom:storage-location erc7201:openzeppelin.storage.ERC20\n    struct ERC20Storage {\n        mapping(address account => uint256) _balances;\n\n        mapping(address account => mapping(address spender => uint256)) _allowances;\n\n        uint256 _totalSupply;\n\n        string _name;\n        string _symbol;\n    }\n\n    // keccak256(abi.encode(uint256(keccak256(\"openzeppelin.storage.ERC20\")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant ERC20StorageLocation = 0x52c63247e1f47db19d5ce0460030c497f067ca4cebf71ba98eeadabe20bace00;\n\n    function _getERC20Storage() private pure returns (ERC20Storage storage $) {\n        assembly {\n            $.slot := ERC20StorageLocation\n        }\n    }\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * Both values are immutable: they can only be set once during construction.\n     */\n    function __ERC20_init(string memory name_, string memory symbol_) internal onlyInitializing {\n        __ERC20_init_unchained(name_, symbol_);\n    }\n\n    function __ERC20_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {\n        ERC20Storage storage $ = _getERC20Storage();\n        $._name = name_;\n        $._symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual returns (string memory) {\n        ERC20Storage storage $ = _getERC20Storage();\n        return $._name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual returns (string memory) {\n        ERC20Storage storage $ = _getERC20Storage();\n        return $._symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the default value returned by this function, unless\n     * it's overridden.\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual returns (uint8) {\n        return 18;\n    }\n\n    /// @inheritdoc IERC20\n    function totalSupply() public view virtual returns (uint256) {\n        ERC20Storage storage $ = _getERC20Storage();\n        return $._totalSupply;\n    }\n\n    /// @inheritdoc IERC20\n    function balanceOf(address account) public view virtual returns (uint256) {\n        ERC20Storage storage $ = _getERC20Storage();\n        return $._balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - the caller must have a balance of at least `value`.\n     */\n    function transfer(address to, uint256 value) public virtual returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, value);\n        return true;\n    }\n\n    /// @inheritdoc IERC20\n    function allowance(address owner, address spender) public view virtual returns (uint256) {\n        ERC20Storage storage $ = _getERC20Storage();\n        return $._allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * NOTE: If `value` is the maximum `uint256`, the allowance is not updated on\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 value) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, value);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Skips emitting an {Approval} event indicating an allowance update. This is not\n     * required by the ERC. See {xref-ERC20-_approve-address-address-uint256-bool-}[_approve].\n     *\n     * NOTE: Does not update the allowance if the current allowance\n     * is the maximum `uint256`.\n     *\n     * Requirements:\n     *\n     * - `from` and `to` cannot be the zero address.\n     * - `from` must have a balance of at least `value`.\n     * - the caller must have allowance for ``from``'s tokens of at least\n     * `value`.\n     */\n    function transferFrom(address from, address to, uint256 value) public virtual returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, value);\n        _transfer(from, to, value);\n        return true;\n    }\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * NOTE: This function is not virtual, {_update} should be overridden instead.\n     */\n    function _transfer(address from, address to, uint256 value) internal {\n        if (from == address(0)) {\n            revert ERC20InvalidSender(address(0));\n        }\n        if (to == address(0)) {\n            revert ERC20InvalidReceiver(address(0));\n        }\n        _update(from, to, value);\n    }\n\n    /**\n     * @dev Transfers a `value` amount of tokens from `from` to `to`, or alternatively mints (or burns) if `from`\n     * (or `to`) is the zero address. All customizations to transfers, mints, and burns should be done by overriding\n     * this function.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _update(address from, address to, uint256 value) internal virtual {\n        ERC20Storage storage $ = _getERC20Storage();\n        if (from == address(0)) {\n            // Overflow check required: The rest of the code assumes that totalSupply never overflows\n            $._totalSupply += value;\n        } else {\n            uint256 fromBalance = $._balances[from];\n            if (fromBalance < value) {\n                revert ERC20InsufficientBalance(from, fromBalance, value);\n            }\n            unchecked {\n                // Overflow not possible: value <= fromBalance <= totalSupply.\n                $._balances[from] = fromBalance - value;\n            }\n        }\n\n        if (to == address(0)) {\n            unchecked {\n                // Overflow not possible: value <= totalSupply or value <= fromBalance <= totalSupply.\n                $._totalSupply -= value;\n            }\n        } else {\n            unchecked {\n                // Overflow not possible: balance + value is at most totalSupply, which we know fits into a uint256.\n                $._balances[to] += value;\n            }\n        }\n\n        emit Transfer(from, to, value);\n    }\n\n    /**\n     * @dev Creates a `value` amount of tokens and assigns them to `account`, by transferring it from address(0).\n     * Relies on the `_update` mechanism\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * NOTE: This function is not virtual, {_update} should be overridden instead.\n     */\n    function _mint(address account, uint256 value) internal {\n        if (account == address(0)) {\n            revert ERC20InvalidReceiver(address(0));\n        }\n        _update(address(0), account, value);\n    }\n\n    /**\n     * @dev Destroys a `value` amount of tokens from `account`, lowering the total supply.\n     * Relies on the `_update` mechanism.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * NOTE: This function is not virtual, {_update} should be overridden instead\n     */\n    function _burn(address account, uint256 value) internal {\n        if (account == address(0)) {\n            revert ERC20InvalidSender(address(0));\n        }\n        _update(account, address(0), value);\n    }\n\n    /**\n     * @dev Sets `value` as the allowance of `spender` over the `owner`'s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     *\n     * Overrides to this logic should be done to the variant with an additional `bool emitEvent` argument.\n     */\n    function _approve(address owner, address spender, uint256 value) internal {\n        _approve(owner, spender, value, true);\n    }\n\n    /**\n     * @dev Variant of {_approve} with an optional flag to enable or disable the {Approval} event.\n     *\n     * By default (when calling {_approve}) the flag is set to true. On the other hand, approval changes made by\n     * `_spendAllowance` during the `transferFrom` operation set the flag to false. This saves gas by not emitting any\n     * `Approval` event during `transferFrom` operations.\n     *\n     * Anyone who wishes to continue emitting `Approval` events on the`transferFrom` operation can force the flag to\n     * true using the following override:\n     *\n     * ```solidity\n     * function _approve(address owner, address spender, uint256 value, bool) internal virtual override {\n     *     super._approve(owner, spender, value, true);\n     * }\n     * ```\n     *\n     * Requirements are the same as {_approve}.\n     */\n    function _approve(address owner, address spender, uint256 value, bool emitEvent) internal virtual {\n        ERC20Storage storage $ = _getERC20Storage();\n        if (owner == address(0)) {\n            revert ERC20InvalidApprover(address(0));\n        }\n        if (spender == address(0)) {\n            revert ERC20InvalidSpender(address(0));\n        }\n        $._allowances[owner][spender] = value;\n        if (emitEvent) {\n            emit Approval(owner, spender, value);\n        }\n    }\n\n    /**\n     * @dev Updates `owner`'s allowance for `spender` based on spent `value`.\n     *\n     * Does not update the allowance value in case of infinite allowance.\n     * Revert if not enough allowance is available.\n     *\n     * Does not emit an {Approval} event.\n     */\n    function _spendAllowance(address owner, address spender, uint256 value) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance < type(uint256).max) {\n            if (currentAllowance < value) {\n                revert ERC20InsufficientAllowance(spender, currentAllowance, value);\n            }\n            unchecked {\n                _approve(owner, spender, currentAllowance - value, false);\n            }\n        }\n    }\n}\n"},"lib/openzeppelin-contracts-upgradeable/contracts/utils/introspection/ERC165Upgradeable.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (utils/introspection/ERC165.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC165} from \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\nimport {Initializable} from \"../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC-165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n */\nabstract contract ERC165Upgradeable is Initializable, IERC165 {\n    function __ERC165_init() internal onlyInitializing {\n    }\n\n    function __ERC165_init_unchained() internal onlyInitializing {\n    }\n    /// @inheritdoc IERC165\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n"},"lib/openzeppelin-contracts-upgradeable/contracts/access/AccessControlUpgradeable.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (access/AccessControl.sol)\n\npragma solidity ^0.8.20;\n\nimport {IAccessControl} from \"@openzeppelin/contracts/access/IAccessControl.sol\";\nimport {ContextUpgradeable} from \"../utils/ContextUpgradeable.sol\";\nimport {IERC165} from \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\nimport {ERC165Upgradeable} from \"../utils/introspection/ERC165Upgradeable.sol\";\nimport {Initializable} from \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module that allows children to implement role-based access\n * control mechanisms. This is a lightweight version that doesn't allow enumerating role\n * members except through off-chain means by accessing the contract event logs. Some\n * applications may benefit from on-chain enumerability, for those cases see\n * {AccessControlEnumerable}.\n *\n * Roles are referred to by their `bytes32` identifier. These should be exposed\n * in the external API and be unique. The best way to achieve this is by\n * using `public constant` hash digests:\n *\n * ```solidity\n * bytes32 public constant MY_ROLE = keccak256(\"MY_ROLE\");\n * ```\n *\n * Roles can be used to represent a set of permissions. To restrict access to a\n * function call, use {hasRole}:\n *\n * ```solidity\n * function foo() public {\n *     require(hasRole(MY_ROLE, msg.sender));\n *     ...\n * }\n * ```\n *\n * Roles can be granted and revoked dynamically via the {grantRole} and\n * {revokeRole} functions. Each role has an associated admin role, and only\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\n *\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\n * that only accounts with this role will be able to grant or revoke other\n * roles. More complex role relationships can be created by using\n * {_setRoleAdmin}.\n *\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\n * grant and revoke this role. Extra precautions should be taken to secure\n * accounts that have been granted it. We recommend using {AccessControlDefaultAdminRules}\n * to enforce additional security measures for this role.\n */\nabstract contract AccessControlUpgradeable is Initializable, ContextUpgradeable, IAccessControl, ERC165Upgradeable {\n    struct RoleData {\n        mapping(address account => bool) hasRole;\n        bytes32 adminRole;\n    }\n\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n\n\n    /// @custom:storage-location erc7201:openzeppelin.storage.AccessControl\n    struct AccessControlStorage {\n        mapping(bytes32 role => RoleData) _roles;\n    }\n\n    // keccak256(abi.encode(uint256(keccak256(\"openzeppelin.storage.AccessControl\")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant AccessControlStorageLocation = 0x02dd7bc7dec4dceedda775e58dd541e08a116c6c53815c0bd028192f7b626800;\n\n    function _getAccessControlStorage() private pure returns (AccessControlStorage storage $) {\n        assembly {\n            $.slot := AccessControlStorageLocation\n        }\n    }\n\n    /**\n     * @dev Modifier that checks that an account has a specific role. Reverts\n     * with an {AccessControlUnauthorizedAccount} error including the required role.\n     */\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role);\n        _;\n    }\n\n    function __AccessControl_init() internal onlyInitializing {\n    }\n\n    function __AccessControl_init_unchained() internal onlyInitializing {\n    }\n    /// @inheritdoc IERC165\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControl).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) public view virtual returns (bool) {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        return $._roles[role].hasRole[account];\n    }\n\n    /**\n     * @dev Reverts with an {AccessControlUnauthorizedAccount} error if `_msgSender()`\n     * is missing `role`. Overriding this function changes the behavior of the {onlyRole} modifier.\n     */\n    function _checkRole(bytes32 role) internal view virtual {\n        _checkRole(role, _msgSender());\n    }\n\n    /**\n     * @dev Reverts with an {AccessControlUnauthorizedAccount} error if `account`\n     * is missing `role`.\n     */\n    function _checkRole(bytes32 role, address account) internal view virtual {\n        if (!hasRole(role, account)) {\n            revert AccessControlUnauthorizedAccount(account, role);\n        }\n    }\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) public view virtual returns (bytes32) {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        return $._roles[role].adminRole;\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function grantRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function revokeRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been revoked `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `callerConfirmation`.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function renounceRole(bytes32 role, address callerConfirmation) public virtual {\n        if (callerConfirmation != _msgSender()) {\n            revert AccessControlBadConfirmation();\n        }\n\n        _revokeRole(role, callerConfirmation);\n    }\n\n    /**\n     * @dev Sets `adminRole` as ``role``'s admin role.\n     *\n     * Emits a {RoleAdminChanged} event.\n     */\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        bytes32 previousAdminRole = getRoleAdmin(role);\n        $._roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }\n\n    /**\n     * @dev Attempts to grant `role` to `account` and returns a boolean indicating if `role` was granted.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function _grantRole(bytes32 role, address account) internal virtual returns (bool) {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        if (!hasRole(role, account)) {\n            $._roles[role].hasRole[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Attempts to revoke `role` from `account` and returns a boolean indicating if `role` was revoked.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function _revokeRole(bytes32 role, address account) internal virtual returns (bool) {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        if (hasRole(role, account)) {\n            $._roles[role].hasRole[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n            return true;\n        } else {\n            return false;\n        }\n    }\n}\n"},"lib/openzeppelin-contracts-upgradeable/contracts/proxy/utils/UUPSUpgradeable.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.3.0) (proxy/utils/UUPSUpgradeable.sol)\n\npragma solidity ^0.8.22;\n\nimport {IERC1822Proxiable} from \"@openzeppelin/contracts/interfaces/draft-IERC1822.sol\";\nimport {ERC1967Utils} from \"@openzeppelin/contracts/proxy/ERC1967/ERC1967Utils.sol\";\nimport {Initializable} from \"./Initializable.sol\";\n\n/**\n * @dev An upgradeability mechanism designed for UUPS proxies. The functions included here can perform an upgrade of an\n * {ERC1967Proxy}, when this contract is set as the implementation behind such a proxy.\n *\n * A security mechanism ensures that an upgrade does not turn off upgradeability accidentally, although this risk is\n * reinstated if the upgrade retains upgradeability but removes the security mechanism, e.g. by replacing\n * `UUPSUpgradeable` with a custom implementation of upgrades.\n *\n * The {_authorizeUpgrade} function must be overridden to include access restriction to the upgrade mechanism.\n */\nabstract contract UUPSUpgradeable is Initializable, IERC1822Proxiable {\n    /// @custom:oz-upgrades-unsafe-allow state-variable-immutable\n    address private immutable __self = address(this);\n\n    /**\n     * @dev The version of the upgrade interface of the contract. If this getter is missing, both `upgradeTo(address)`\n     * and `upgradeToAndCall(address,bytes)` are present, and `upgradeTo` must be used if no function should be called,\n     * while `upgradeToAndCall` will invoke the `receive` function if the second argument is the empty byte string.\n     * If the getter returns `\"5.0.0\"`, only `upgradeToAndCall(address,bytes)` is present, and the second argument must\n     * be the empty byte string if no function should be called, making it impossible to invoke the `receive` function\n     * during an upgrade.\n     */\n    string public constant UPGRADE_INTERFACE_VERSION = \"5.0.0\";\n\n    /**\n     * @dev The call is from an unauthorized context.\n     */\n    error UUPSUnauthorizedCallContext();\n\n    /**\n     * @dev The storage `slot` is unsupported as a UUID.\n     */\n    error UUPSUnsupportedProxiableUUID(bytes32 slot);\n\n    /**\n     * @dev Check that the execution is being performed through a delegatecall call and that the execution context is\n     * a proxy contract with an implementation (as defined in ERC-1967) pointing to self. This should only be the case\n     * for UUPS and transparent proxies that are using the current contract as their implementation. Execution of a\n     * function through ERC-1167 minimal proxies (clones) would not normally pass this test, but is not guaranteed to\n     * fail.\n     */\n    modifier onlyProxy() {\n        _checkProxy();\n        _;\n    }\n\n    /**\n     * @dev Check that the execution is not being performed through a delegate call. This allows a function to be\n     * callable on the implementing contract but not through proxies.\n     */\n    modifier notDelegated() {\n        _checkNotDelegated();\n        _;\n    }\n\n    function __UUPSUpgradeable_init() internal onlyInitializing {\n    }\n\n    function __UUPSUpgradeable_init_unchained() internal onlyInitializing {\n    }\n    /**\n     * @dev Implementation of the ERC-1822 {proxiableUUID} function. This returns the storage slot used by the\n     * implementation. It is used to validate the implementation's compatibility when performing an upgrade.\n     *\n     * IMPORTANT: A proxy pointing at a proxiable contract should not be considered proxiable itself, because this risks\n     * bricking a proxy that upgrades to it, by delegating to itself until out of gas. Thus it is critical that this\n     * function revert if invoked through a proxy. This is guaranteed by the `notDelegated` modifier.\n     */\n    function proxiableUUID() external view virtual notDelegated returns (bytes32) {\n        return ERC1967Utils.IMPLEMENTATION_SLOT;\n    }\n\n    /**\n     * @dev Upgrade the implementation of the proxy to `newImplementation`, and subsequently execute the function call\n     * encoded in `data`.\n     *\n     * Calls {_authorizeUpgrade}.\n     *\n     * Emits an {Upgraded} event.\n     *\n     * @custom:oz-upgrades-unsafe-allow-reachable delegatecall\n     */\n    function upgradeToAndCall(address newImplementation, bytes memory data) public payable virtual onlyProxy {\n        _authorizeUpgrade(newImplementation);\n        _upgradeToAndCallUUPS(newImplementation, data);\n    }\n\n    /**\n     * @dev Reverts if the execution is not performed via delegatecall or the execution\n     * context is not of a proxy with an ERC-1967 compliant implementation pointing to self.\n     */\n    function _checkProxy() internal view virtual {\n        if (\n            address(this) == __self || // Must be called through delegatecall\n            ERC1967Utils.getImplementation() != __self // Must be called through an active proxy\n        ) {\n            revert UUPSUnauthorizedCallContext();\n        }\n    }\n\n    /**\n     * @dev Reverts if the execution is performed via delegatecall.\n     * See {notDelegated}.\n     */\n    function _checkNotDelegated() internal view virtual {\n        if (address(this) != __self) {\n            // Must not be called through delegatecall\n            revert UUPSUnauthorizedCallContext();\n        }\n    }\n\n    /**\n     * @dev Function that should revert when `msg.sender` is not authorized to upgrade the contract. Called by\n     * {upgradeToAndCall}.\n     *\n     * Normally, this function will use an xref:access.adoc[access control] modifier such as {Ownable-onlyOwner}.\n     *\n     * ```solidity\n     * function _authorizeUpgrade(address) internal onlyOwner {}\n     * ```\n     */\n    function _authorizeUpgrade(address newImplementation) internal virtual;\n\n    /**\n     * @dev Performs an implementation upgrade with a security check for UUPS proxies, and additional setup call.\n     *\n     * As a security check, {proxiableUUID} is invoked in the new implementation, and the return value\n     * is expected to be the implementation slot in ERC-1967.\n     *\n     * Emits an {IERC1967-Upgraded} event.\n     */\n    function _upgradeToAndCallUUPS(address newImplementation, bytes memory data) private {\n        try IERC1822Proxiable(newImplementation).proxiableUUID() returns (bytes32 slot) {\n            if (slot != ERC1967Utils.IMPLEMENTATION_SLOT) {\n                revert UUPSUnsupportedProxiableUUID(slot);\n            }\n            ERC1967Utils.upgradeToAndCall(newImplementation, data);\n        } catch {\n            // The implementation is not UUPS\n            revert ERC1967Utils.ERC1967InvalidImplementation(newImplementation);\n        }\n    }\n}\n"},"lib/openzeppelin-contracts/contracts/interfaces/IERC165.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (interfaces/IERC165.sol)\n\npragma solidity >=0.4.16;\n\nimport {IERC165} from \"../utils/introspection/IERC165.sol\";\n"},"lib/openzeppelin-contracts/contracts/token/ERC20/extensions/IERC20Metadata.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity >=0.6.2;\n\nimport {IERC20} from \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC-20 standard.\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"},"lib/openzeppelin-contracts/contracts/access/IAccessControl.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (access/IAccessControl.sol)\n\npragma solidity >=0.8.4;\n\n/**\n * @dev External interface of AccessControl declared to support ERC-165 detection.\n */\ninterface IAccessControl {\n    /**\n     * @dev The `account` is missing a role.\n     */\n    error AccessControlUnauthorizedAccount(address account, bytes32 neededRole);\n\n    /**\n     * @dev The caller of a function is not the expected one.\n     *\n     * NOTE: Don't confuse with {AccessControlUnauthorizedAccount}.\n     */\n    error AccessControlBadConfirmation();\n\n    /**\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\n     *\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\n     * {RoleAdminChanged} not being emitted to signal this.\n     */\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n\n    /**\n     * @dev Emitted when `account` is granted `role`.\n     *\n     * `sender` is the account that originated the contract call. This account bears the admin role (for the granted role).\n     * Expected in cases where the role was granted using the internal {AccessControl-_grantRole}.\n     */\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Emitted when `account` is revoked `role`.\n     *\n     * `sender` is the account that originated the contract call:\n     *   - if using `revokeRole`, it is the admin role bearer\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\n     */\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) external view returns (bool);\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `callerConfirmation`.\n     */\n    function renounceRole(bytes32 role, address callerConfirmation) external;\n}\n"},"lib/openzeppelin-contracts/contracts/interfaces/draft-IERC1822.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (interfaces/draft-IERC1822.sol)\n\npragma solidity >=0.4.16;\n\n/**\n * @dev ERC-1822: Universal Upgradeable Proxy Standard (UUPS) documents a method for upgradeability through a simplified\n * proxy whose upgrades are fully controlled by the current implementation.\n */\ninterface IERC1822Proxiable {\n    /**\n     * @dev Returns the storage slot that the proxiable contract assumes is being used to store the implementation\n     * address.\n     *\n     * IMPORTANT: A proxy pointing at a proxiable contract should not be considered proxiable itself, because this risks\n     * bricking a proxy that upgrades to it, by delegating to itself until out of gas. Thus it is critical that this\n     * function revert if invoked through a proxy.\n     */\n    function proxiableUUID() external view returns (bytes32);\n}\n"},"lib/openzeppelin-contracts-upgradeable/contracts/utils/PausableUpgradeable.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.3.0) (utils/Pausable.sol)\n\npragma solidity ^0.8.20;\n\nimport {ContextUpgradeable} from \"../utils/ContextUpgradeable.sol\";\nimport {Initializable} from \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module which allows children to implement an emergency stop\n * mechanism that can be triggered by an authorized account.\n *\n * This module is used through inheritance. It will make available the\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\n * the functions of your contract. Note that they will not be pausable by\n * simply including this module, only once the modifiers are put in place.\n */\nabstract contract PausableUpgradeable is Initializable, ContextUpgradeable {\n    /// @custom:storage-location erc7201:openzeppelin.storage.Pausable\n    struct PausableStorage {\n        bool _paused;\n    }\n\n    // keccak256(abi.encode(uint256(keccak256(\"openzeppelin.storage.Pausable\")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant PausableStorageLocation = 0xcd5ed15c6e187e77e9aee88184c21f4f2182ab5827cb3b7e07fbedcd63f03300;\n\n    function _getPausableStorage() private pure returns (PausableStorage storage $) {\n        assembly {\n            $.slot := PausableStorageLocation\n        }\n    }\n\n    /**\n     * @dev Emitted when the pause is triggered by `account`.\n     */\n    event Paused(address account);\n\n    /**\n     * @dev Emitted when the pause is lifted by `account`.\n     */\n    event Unpaused(address account);\n\n    /**\n     * @dev The operation failed because the contract is paused.\n     */\n    error EnforcedPause();\n\n    /**\n     * @dev The operation failed because the contract is not paused.\n     */\n    error ExpectedPause();\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is not paused.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    modifier whenNotPaused() {\n        _requireNotPaused();\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is paused.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    modifier whenPaused() {\n        _requirePaused();\n        _;\n    }\n\n    function __Pausable_init() internal onlyInitializing {\n    }\n\n    function __Pausable_init_unchained() internal onlyInitializing {\n    }\n    /**\n     * @dev Returns true if the contract is paused, and false otherwise.\n     */\n    function paused() public view virtual returns (bool) {\n        PausableStorage storage $ = _getPausableStorage();\n        return $._paused;\n    }\n\n    /**\n     * @dev Throws if the contract is paused.\n     */\n    function _requireNotPaused() internal view virtual {\n        if (paused()) {\n            revert EnforcedPause();\n        }\n    }\n\n    /**\n     * @dev Throws if the contract is not paused.\n     */\n    function _requirePaused() internal view virtual {\n        if (!paused()) {\n            revert ExpectedPause();\n        }\n    }\n\n    /**\n     * @dev Triggers stopped state.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    function _pause() internal virtual whenNotPaused {\n        PausableStorage storage $ = _getPausableStorage();\n        $._paused = true;\n        emit Paused(_msgSender());\n    }\n\n    /**\n     * @dev Returns to normal state.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    function _unpause() internal virtual whenPaused {\n        PausableStorage storage $ = _getPausableStorage();\n        $._paused = false;\n        emit Unpaused(_msgSender());\n    }\n}\n"},"lib/openzeppelin-contracts/contracts/token/ERC20/utils/SafeERC20.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.3.0) (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC20} from \"../IERC20.sol\";\nimport {IERC1363} from \"../../../interfaces/IERC1363.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC-20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    /**\n     * @dev An operation with an ERC-20 token failed.\n     */\n    error SafeERC20FailedOperation(address token);\n\n    /**\n     * @dev Indicates a failed `decreaseAllowance` request.\n     */\n    error SafeERC20FailedDecreaseAllowance(address spender, uint256 currentAllowance, uint256 requestedDecrease);\n\n    /**\n     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeCall(token.transfer, (to, value)));\n    }\n\n    /**\n     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\n     */\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeCall(token.transferFrom, (from, to, value)));\n    }\n\n    /**\n     * @dev Variant of {safeTransfer} that returns a bool instead of reverting if the operation is not successful.\n     */\n    function trySafeTransfer(IERC20 token, address to, uint256 value) internal returns (bool) {\n        return _callOptionalReturnBool(token, abi.encodeCall(token.transfer, (to, value)));\n    }\n\n    /**\n     * @dev Variant of {safeTransferFrom} that returns a bool instead of reverting if the operation is not successful.\n     */\n    function trySafeTransferFrom(IERC20 token, address from, address to, uint256 value) internal returns (bool) {\n        return _callOptionalReturnBool(token, abi.encodeCall(token.transferFrom, (from, to, value)));\n    }\n\n    /**\n     * @dev Increase the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     *\n     * IMPORTANT: If the token implements ERC-7674 (ERC-20 with temporary allowance), and if the \"client\"\n     * smart contract uses ERC-7674 to set temporary allowances, then the \"client\" smart contract should avoid using\n     * this function. Performing a {safeIncreaseAllowance} or {safeDecreaseAllowance} operation on a token contract\n     * that has a non-zero temporary allowance (for that particular owner-spender) will result in unexpected behavior.\n     */\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 oldAllowance = token.allowance(address(this), spender);\n        forceApprove(token, spender, oldAllowance + value);\n    }\n\n    /**\n     * @dev Decrease the calling contract's allowance toward `spender` by `requestedDecrease`. If `token` returns no\n     * value, non-reverting calls are assumed to be successful.\n     *\n     * IMPORTANT: If the token implements ERC-7674 (ERC-20 with temporary allowance), and if the \"client\"\n     * smart contract uses ERC-7674 to set temporary allowances, then the \"client\" smart contract should avoid using\n     * this function. Performing a {safeIncreaseAllowance} or {safeDecreaseAllowance} operation on a token contract\n     * that has a non-zero temporary allowance (for that particular owner-spender) will result in unexpected behavior.\n     */\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 requestedDecrease) internal {\n        unchecked {\n            uint256 currentAllowance = token.allowance(address(this), spender);\n            if (currentAllowance < requestedDecrease) {\n                revert SafeERC20FailedDecreaseAllowance(spender, currentAllowance, requestedDecrease);\n            }\n            forceApprove(token, spender, currentAllowance - requestedDecrease);\n        }\n    }\n\n    /**\n     * @dev Set the calling contract's allowance toward `spender` to `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful. Meant to be used with tokens that require the approval\n     * to be set to zero before setting it to a non-zero value, such as USDT.\n     *\n     * NOTE: If the token implements ERC-7674, this function will not modify any temporary allowance. This function\n     * only sets the \"standard\" allowance. Any temporary allowance will remain active, in addition to the value being\n     * set here.\n     */\n    function forceApprove(IERC20 token, address spender, uint256 value) internal {\n        bytes memory approvalCall = abi.encodeCall(token.approve, (spender, value));\n\n        if (!_callOptionalReturnBool(token, approvalCall)) {\n            _callOptionalReturn(token, abi.encodeCall(token.approve, (spender, 0)));\n            _callOptionalReturn(token, approvalCall);\n        }\n    }\n\n    /**\n     * @dev Performs an {ERC1363} transferAndCall, with a fallback to the simple {ERC20} transfer if the target has no\n     * code. This can be used to implement an {ERC721}-like safe transfer that rely on {ERC1363} checks when\n     * targeting contracts.\n     *\n     * Reverts if the returned value is other than `true`.\n     */\n    function transferAndCallRelaxed(IERC1363 token, address to, uint256 value, bytes memory data) internal {\n        if (to.code.length == 0) {\n            safeTransfer(token, to, value);\n        } else if (!token.transferAndCall(to, value, data)) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }\n\n    /**\n     * @dev Performs an {ERC1363} transferFromAndCall, with a fallback to the simple {ERC20} transferFrom if the target\n     * has no code. This can be used to implement an {ERC721}-like safe transfer that rely on {ERC1363} checks when\n     * targeting contracts.\n     *\n     * Reverts if the returned value is other than `true`.\n     */\n    function transferFromAndCallRelaxed(\n        IERC1363 token,\n        address from,\n        address to,\n        uint256 value,\n        bytes memory data\n    ) internal {\n        if (to.code.length == 0) {\n            safeTransferFrom(token, from, to, value);\n        } else if (!token.transferFromAndCall(from, to, value, data)) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }\n\n    /**\n     * @dev Performs an {ERC1363} approveAndCall, with a fallback to the simple {ERC20} approve if the target has no\n     * code. This can be used to implement an {ERC721}-like safe transfer that rely on {ERC1363} checks when\n     * targeting contracts.\n     *\n     * NOTE: When the recipient address (`to`) has no code (i.e. is an EOA), this function behaves as {forceApprove}.\n     * Opposedly, when the recipient address (`to`) has code, this function only attempts to call {ERC1363-approveAndCall}\n     * once without retrying, and relies on the returned value to be true.\n     *\n     * Reverts if the returned value is other than `true`.\n     */\n    function approveAndCallRelaxed(IERC1363 token, address to, uint256 value, bytes memory data) internal {\n        if (to.code.length == 0) {\n            forceApprove(token, to, value);\n        } else if (!token.approveAndCall(to, value, data)) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     *\n     * This is a variant of {_callOptionalReturnBool} that reverts if call fails to meet the requirements.\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        uint256 returnSize;\n        uint256 returnValue;\n        assembly (\"memory-safe\") {\n            let success := call(gas(), token, 0, add(data, 0x20), mload(data), 0, 0x20)\n            // bubble errors\n            if iszero(success) {\n                let ptr := mload(0x40)\n                returndatacopy(ptr, 0, returndatasize())\n                revert(ptr, returndatasize())\n            }\n            returnSize := returndatasize()\n            returnValue := mload(0)\n        }\n\n        if (returnSize == 0 ? address(token).code.length == 0 : returnValue != 1) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     *\n     * This is a variant of {_callOptionalReturn} that silently catches all reverts and returns a bool instead.\n     */\n    function _callOptionalReturnBool(IERC20 token, bytes memory data) private returns (bool) {\n        bool success;\n        uint256 returnSize;\n        uint256 returnValue;\n        assembly (\"memory-safe\") {\n            success := call(gas(), token, 0, add(data, 0x20), mload(data), 0, 0x20)\n            returnSize := returndatasize()\n            returnValue := mload(0)\n        }\n        return success && (returnSize == 0 ? address(token).code.length > 0 : returnValue == 1);\n    }\n}\n"},"lib/openzeppelin-contracts/contracts/utils/Panic.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/Panic.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Helper library for emitting standardized panic codes.\n *\n * ```solidity\n * contract Example {\n *      using Panic for uint256;\n *\n *      // Use any of the declared internal constants\n *      function foo() { Panic.GENERIC.panic(); }\n *\n *      // Alternatively\n *      function foo() { Panic.panic(Panic.GENERIC); }\n * }\n * ```\n *\n * Follows the list from https://github.com/ethereum/solidity/blob/v0.8.24/libsolutil/ErrorCodes.h[libsolutil].\n *\n * _Available since v5.1._\n */\n// slither-disable-next-line unused-state\nlibrary Panic {\n    /// @dev generic / unspecified error\n    uint256 internal constant GENERIC = 0x00;\n    /// @dev used by the assert() builtin\n    uint256 internal constant ASSERT = 0x01;\n    /// @dev arithmetic underflow or overflow\n    uint256 internal constant UNDER_OVERFLOW = 0x11;\n    /// @dev division or modulo by zero\n    uint256 internal constant DIVISION_BY_ZERO = 0x12;\n    /// @dev enum conversion error\n    uint256 internal constant ENUM_CONVERSION_ERROR = 0x21;\n    /// @dev invalid encoding in storage\n    uint256 internal constant STORAGE_ENCODING_ERROR = 0x22;\n    /// @dev empty array pop\n    uint256 internal constant EMPTY_ARRAY_POP = 0x31;\n    /// @dev array out of bounds access\n    uint256 internal constant ARRAY_OUT_OF_BOUNDS = 0x32;\n    /// @dev resource error (too large allocation or too large array)\n    uint256 internal constant RESOURCE_ERROR = 0x41;\n    /// @dev calling invalid internal function\n    uint256 internal constant INVALID_INTERNAL_FUNCTION = 0x51;\n\n    /// @dev Reverts with a panic code. Recommended to use with\n    /// the internal constants with predefined codes.\n    function panic(uint256 code) internal pure {\n        assembly (\"memory-safe\") {\n            mstore(0x00, 0x4e487b71)\n            mstore(0x20, code)\n            revert(0x1c, 0x24)\n        }\n    }\n}\n"},"lib/openzeppelin-contracts/contracts/utils/math/SafeCast.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/math/SafeCast.sol)\n// This file was procedurally generated from scripts/generate/templates/SafeCast.js.\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Wrappers over Solidity's uintXX/intXX/bool casting operators with added overflow\n * checks.\n *\n * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\n * easily result in undesired exploitation or bugs, since developers usually\n * assume that overflows raise errors. `SafeCast` restores this intuition by\n * reverting the transaction when such an operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeCast {\n    /**\n     * @dev Value doesn't fit in an uint of `bits` size.\n     */\n    error SafeCastOverflowedUintDowncast(uint8 bits, uint256 value);\n\n    /**\n     * @dev An int value doesn't fit in an uint of `bits` size.\n     */\n    error SafeCastOverflowedIntToUint(int256 value);\n\n    /**\n     * @dev Value doesn't fit in an int of `bits` size.\n     */\n    error SafeCastOverflowedIntDowncast(uint8 bits, int256 value);\n\n    /**\n     * @dev An uint value doesn't fit in an int of `bits` size.\n     */\n    error SafeCastOverflowedUintToInt(uint256 value);\n\n    /**\n     * @dev Returns the downcasted uint248 from uint256, reverting on\n     * overflow (when the input is greater than largest uint248).\n     *\n     * Counterpart to Solidity's `uint248` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 248 bits\n     */\n    function toUint248(uint256 value) internal pure returns (uint248) {\n        if (value > type(uint248).max) {\n            revert SafeCastOverflowedUintDowncast(248, value);\n        }\n        return uint248(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint240 from uint256, reverting on\n     * overflow (when the input is greater than largest uint240).\n     *\n     * Counterpart to Solidity's `uint240` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 240 bits\n     */\n    function toUint240(uint256 value) internal pure returns (uint240) {\n        if (value > type(uint240).max) {\n            revert SafeCastOverflowedUintDowncast(240, value);\n        }\n        return uint240(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint232 from uint256, reverting on\n     * overflow (when the input is greater than largest uint232).\n     *\n     * Counterpart to Solidity's `uint232` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 232 bits\n     */\n    function toUint232(uint256 value) internal pure returns (uint232) {\n        if (value > type(uint232).max) {\n            revert SafeCastOverflowedUintDowncast(232, value);\n        }\n        return uint232(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint224 from uint256, reverting on\n     * overflow (when the input is greater than largest uint224).\n     *\n     * Counterpart to Solidity's `uint224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     */\n    function toUint224(uint256 value) internal pure returns (uint224) {\n        if (value > type(uint224).max) {\n            revert SafeCastOverflowedUintDowncast(224, value);\n        }\n        return uint224(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint216 from uint256, reverting on\n     * overflow (when the input is greater than largest uint216).\n     *\n     * Counterpart to Solidity's `uint216` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 216 bits\n     */\n    function toUint216(uint256 value) internal pure returns (uint216) {\n        if (value > type(uint216).max) {\n            revert SafeCastOverflowedUintDowncast(216, value);\n        }\n        return uint216(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint208 from uint256, reverting on\n     * overflow (when the input is greater than largest uint208).\n     *\n     * Counterpart to Solidity's `uint208` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 208 bits\n     */\n    function toUint208(uint256 value) internal pure returns (uint208) {\n        if (value > type(uint208).max) {\n            revert SafeCastOverflowedUintDowncast(208, value);\n        }\n        return uint208(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint200 from uint256, reverting on\n     * overflow (when the input is greater than largest uint200).\n     *\n     * Counterpart to Solidity's `uint200` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 200 bits\n     */\n    function toUint200(uint256 value) internal pure returns (uint200) {\n        if (value > type(uint200).max) {\n            revert SafeCastOverflowedUintDowncast(200, value);\n        }\n        return uint200(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint192 from uint256, reverting on\n     * overflow (when the input is greater than largest uint192).\n     *\n     * Counterpart to Solidity's `uint192` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 192 bits\n     */\n    function toUint192(uint256 value) internal pure returns (uint192) {\n        if (value > type(uint192).max) {\n            revert SafeCastOverflowedUintDowncast(192, value);\n        }\n        return uint192(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint184 from uint256, reverting on\n     * overflow (when the input is greater than largest uint184).\n     *\n     * Counterpart to Solidity's `uint184` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 184 bits\n     */\n    function toUint184(uint256 value) internal pure returns (uint184) {\n        if (value > type(uint184).max) {\n            revert SafeCastOverflowedUintDowncast(184, value);\n        }\n        return uint184(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint176 from uint256, reverting on\n     * overflow (when the input is greater than largest uint176).\n     *\n     * Counterpart to Solidity's `uint176` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 176 bits\n     */\n    function toUint176(uint256 value) internal pure returns (uint176) {\n        if (value > type(uint176).max) {\n            revert SafeCastOverflowedUintDowncast(176, value);\n        }\n        return uint176(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint168 from uint256, reverting on\n     * overflow (when the input is greater than largest uint168).\n     *\n     * Counterpart to Solidity's `uint168` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 168 bits\n     */\n    function toUint168(uint256 value) internal pure returns (uint168) {\n        if (value > type(uint168).max) {\n            revert SafeCastOverflowedUintDowncast(168, value);\n        }\n        return uint168(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint160 from uint256, reverting on\n     * overflow (when the input is greater than largest uint160).\n     *\n     * Counterpart to Solidity's `uint160` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 160 bits\n     */\n    function toUint160(uint256 value) internal pure returns (uint160) {\n        if (value > type(uint160).max) {\n            revert SafeCastOverflowedUintDowncast(160, value);\n        }\n        return uint160(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint152 from uint256, reverting on\n     * overflow (when the input is greater than largest uint152).\n     *\n     * Counterpart to Solidity's `uint152` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 152 bits\n     */\n    function toUint152(uint256 value) internal pure returns (uint152) {\n        if (value > type(uint152).max) {\n            revert SafeCastOverflowedUintDowncast(152, value);\n        }\n        return uint152(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint144 from uint256, reverting on\n     * overflow (when the input is greater than largest uint144).\n     *\n     * Counterpart to Solidity's `uint144` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 144 bits\n     */\n    function toUint144(uint256 value) internal pure returns (uint144) {\n        if (value > type(uint144).max) {\n            revert SafeCastOverflowedUintDowncast(144, value);\n        }\n        return uint144(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint136 from uint256, reverting on\n     * overflow (when the input is greater than largest uint136).\n     *\n     * Counterpart to Solidity's `uint136` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 136 bits\n     */\n    function toUint136(uint256 value) internal pure returns (uint136) {\n        if (value > type(uint136).max) {\n            revert SafeCastOverflowedUintDowncast(136, value);\n        }\n        return uint136(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint128 from uint256, reverting on\n     * overflow (when the input is greater than largest uint128).\n     *\n     * Counterpart to Solidity's `uint128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     */\n    function toUint128(uint256 value) internal pure returns (uint128) {\n        if (value > type(uint128).max) {\n            revert SafeCastOverflowedUintDowncast(128, value);\n        }\n        return uint128(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint120 from uint256, reverting on\n     * overflow (when the input is greater than largest uint120).\n     *\n     * Counterpart to Solidity's `uint120` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 120 bits\n     */\n    function toUint120(uint256 value) internal pure returns (uint120) {\n        if (value > type(uint120).max) {\n            revert SafeCastOverflowedUintDowncast(120, value);\n        }\n        return uint120(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint112 from uint256, reverting on\n     * overflow (when the input is greater than largest uint112).\n     *\n     * Counterpart to Solidity's `uint112` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 112 bits\n     */\n    function toUint112(uint256 value) internal pure returns (uint112) {\n        if (value > type(uint112).max) {\n            revert SafeCastOverflowedUintDowncast(112, value);\n        }\n        return uint112(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint104 from uint256, reverting on\n     * overflow (when the input is greater than largest uint104).\n     *\n     * Counterpart to Solidity's `uint104` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 104 bits\n     */\n    function toUint104(uint256 value) internal pure returns (uint104) {\n        if (value > type(uint104).max) {\n            revert SafeCastOverflowedUintDowncast(104, value);\n        }\n        return uint104(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint96 from uint256, reverting on\n     * overflow (when the input is greater than largest uint96).\n     *\n     * Counterpart to Solidity's `uint96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     */\n    function toUint96(uint256 value) internal pure returns (uint96) {\n        if (value > type(uint96).max) {\n            revert SafeCastOverflowedUintDowncast(96, value);\n        }\n        return uint96(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint88 from uint256, reverting on\n     * overflow (when the input is greater than largest uint88).\n     *\n     * Counterpart to Solidity's `uint88` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 88 bits\n     */\n    function toUint88(uint256 value) internal pure returns (uint88) {\n        if (value > type(uint88).max) {\n            revert SafeCastOverflowedUintDowncast(88, value);\n        }\n        return uint88(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint80 from uint256, reverting on\n     * overflow (when the input is greater than largest uint80).\n     *\n     * Counterpart to Solidity's `uint80` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 80 bits\n     */\n    function toUint80(uint256 value) internal pure returns (uint80) {\n        if (value > type(uint80).max) {\n            revert SafeCastOverflowedUintDowncast(80, value);\n        }\n        return uint80(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint72 from uint256, reverting on\n     * overflow (when the input is greater than largest uint72).\n     *\n     * Counterpart to Solidity's `uint72` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 72 bits\n     */\n    function toUint72(uint256 value) internal pure returns (uint72) {\n        if (value > type(uint72).max) {\n            revert SafeCastOverflowedUintDowncast(72, value);\n        }\n        return uint72(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint64 from uint256, reverting on\n     * overflow (when the input is greater than largest uint64).\n     *\n     * Counterpart to Solidity's `uint64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     */\n    function toUint64(uint256 value) internal pure returns (uint64) {\n        if (value > type(uint64).max) {\n            revert SafeCastOverflowedUintDowncast(64, value);\n        }\n        return uint64(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint56 from uint256, reverting on\n     * overflow (when the input is greater than largest uint56).\n     *\n     * Counterpart to Solidity's `uint56` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 56 bits\n     */\n    function toUint56(uint256 value) internal pure returns (uint56) {\n        if (value > type(uint56).max) {\n            revert SafeCastOverflowedUintDowncast(56, value);\n        }\n        return uint56(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint48 from uint256, reverting on\n     * overflow (when the input is greater than largest uint48).\n     *\n     * Counterpart to Solidity's `uint48` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 48 bits\n     */\n    function toUint48(uint256 value) internal pure returns (uint48) {\n        if (value > type(uint48).max) {\n            revert SafeCastOverflowedUintDowncast(48, value);\n        }\n        return uint48(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint40 from uint256, reverting on\n     * overflow (when the input is greater than largest uint40).\n     *\n     * Counterpart to Solidity's `uint40` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 40 bits\n     */\n    function toUint40(uint256 value) internal pure returns (uint40) {\n        if (value > type(uint40).max) {\n            revert SafeCastOverflowedUintDowncast(40, value);\n        }\n        return uint40(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint32 from uint256, reverting on\n     * overflow (when the input is greater than largest uint32).\n     *\n     * Counterpart to Solidity's `uint32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     */\n    function toUint32(uint256 value) internal pure returns (uint32) {\n        if (value > type(uint32).max) {\n            revert SafeCastOverflowedUintDowncast(32, value);\n        }\n        return uint32(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint24 from uint256, reverting on\n     * overflow (when the input is greater than largest uint24).\n     *\n     * Counterpart to Solidity's `uint24` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 24 bits\n     */\n    function toUint24(uint256 value) internal pure returns (uint24) {\n        if (value > type(uint24).max) {\n            revert SafeCastOverflowedUintDowncast(24, value);\n        }\n        return uint24(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint16 from uint256, reverting on\n     * overflow (when the input is greater than largest uint16).\n     *\n     * Counterpart to Solidity's `uint16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     */\n    function toUint16(uint256 value) internal pure returns (uint16) {\n        if (value > type(uint16).max) {\n            revert SafeCastOverflowedUintDowncast(16, value);\n        }\n        return uint16(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint8 from uint256, reverting on\n     * overflow (when the input is greater than largest uint8).\n     *\n     * Counterpart to Solidity's `uint8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits\n     */\n    function toUint8(uint256 value) internal pure returns (uint8) {\n        if (value > type(uint8).max) {\n            revert SafeCastOverflowedUintDowncast(8, value);\n        }\n        return uint8(value);\n    }\n\n    /**\n     * @dev Converts a signed int256 into an unsigned uint256.\n     *\n     * Requirements:\n     *\n     * - input must be greater than or equal to 0.\n     */\n    function toUint256(int256 value) internal pure returns (uint256) {\n        if (value < 0) {\n            revert SafeCastOverflowedIntToUint(value);\n        }\n        return uint256(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int248 from int256, reverting on\n     * overflow (when the input is less than smallest int248 or\n     * greater than largest int248).\n     *\n     * Counterpart to Solidity's `int248` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 248 bits\n     */\n    function toInt248(int256 value) internal pure returns (int248 downcasted) {\n        downcasted = int248(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(248, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int240 from int256, reverting on\n     * overflow (when the input is less than smallest int240 or\n     * greater than largest int240).\n     *\n     * Counterpart to Solidity's `int240` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 240 bits\n     */\n    function toInt240(int256 value) internal pure returns (int240 downcasted) {\n        downcasted = int240(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(240, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int232 from int256, reverting on\n     * overflow (when the input is less than smallest int232 or\n     * greater than largest int232).\n     *\n     * Counterpart to Solidity's `int232` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 232 bits\n     */\n    function toInt232(int256 value) internal pure returns (int232 downcasted) {\n        downcasted = int232(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(232, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int224 from int256, reverting on\n     * overflow (when the input is less than smallest int224 or\n     * greater than largest int224).\n     *\n     * Counterpart to Solidity's `int224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     */\n    function toInt224(int256 value) internal pure returns (int224 downcasted) {\n        downcasted = int224(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(224, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int216 from int256, reverting on\n     * overflow (when the input is less than smallest int216 or\n     * greater than largest int216).\n     *\n     * Counterpart to Solidity's `int216` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 216 bits\n     */\n    function toInt216(int256 value) internal pure returns (int216 downcasted) {\n        downcasted = int216(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(216, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int208 from int256, reverting on\n     * overflow (when the input is less than smallest int208 or\n     * greater than largest int208).\n     *\n     * Counterpart to Solidity's `int208` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 208 bits\n     */\n    function toInt208(int256 value) internal pure returns (int208 downcasted) {\n        downcasted = int208(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(208, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int200 from int256, reverting on\n     * overflow (when the input is less than smallest int200 or\n     * greater than largest int200).\n     *\n     * Counterpart to Solidity's `int200` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 200 bits\n     */\n    function toInt200(int256 value) internal pure returns (int200 downcasted) {\n        downcasted = int200(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(200, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int192 from int256, reverting on\n     * overflow (when the input is less than smallest int192 or\n     * greater than largest int192).\n     *\n     * Counterpart to Solidity's `int192` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 192 bits\n     */\n    function toInt192(int256 value) internal pure returns (int192 downcasted) {\n        downcasted = int192(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(192, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int184 from int256, reverting on\n     * overflow (when the input is less than smallest int184 or\n     * greater than largest int184).\n     *\n     * Counterpart to Solidity's `int184` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 184 bits\n     */\n    function toInt184(int256 value) internal pure returns (int184 downcasted) {\n        downcasted = int184(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(184, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int176 from int256, reverting on\n     * overflow (when the input is less than smallest int176 or\n     * greater than largest int176).\n     *\n     * Counterpart to Solidity's `int176` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 176 bits\n     */\n    function toInt176(int256 value) internal pure returns (int176 downcasted) {\n        downcasted = int176(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(176, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int168 from int256, reverting on\n     * overflow (when the input is less than smallest int168 or\n     * greater than largest int168).\n     *\n     * Counterpart to Solidity's `int168` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 168 bits\n     */\n    function toInt168(int256 value) internal pure returns (int168 downcasted) {\n        downcasted = int168(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(168, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int160 from int256, reverting on\n     * overflow (when the input is less than smallest int160 or\n     * greater than largest int160).\n     *\n     * Counterpart to Solidity's `int160` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 160 bits\n     */\n    function toInt160(int256 value) internal pure returns (int160 downcasted) {\n        downcasted = int160(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(160, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int152 from int256, reverting on\n     * overflow (when the input is less than smallest int152 or\n     * greater than largest int152).\n     *\n     * Counterpart to Solidity's `int152` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 152 bits\n     */\n    function toInt152(int256 value) internal pure returns (int152 downcasted) {\n        downcasted = int152(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(152, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int144 from int256, reverting on\n     * overflow (when the input is less than smallest int144 or\n     * greater than largest int144).\n     *\n     * Counterpart to Solidity's `int144` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 144 bits\n     */\n    function toInt144(int256 value) internal pure returns (int144 downcasted) {\n        downcasted = int144(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(144, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int136 from int256, reverting on\n     * overflow (when the input is less than smallest int136 or\n     * greater than largest int136).\n     *\n     * Counterpart to Solidity's `int136` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 136 bits\n     */\n    function toInt136(int256 value) internal pure returns (int136 downcasted) {\n        downcasted = int136(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(136, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int128 from int256, reverting on\n     * overflow (when the input is less than smallest int128 or\n     * greater than largest int128).\n     *\n     * Counterpart to Solidity's `int128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     */\n    function toInt128(int256 value) internal pure returns (int128 downcasted) {\n        downcasted = int128(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(128, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int120 from int256, reverting on\n     * overflow (when the input is less than smallest int120 or\n     * greater than largest int120).\n     *\n     * Counterpart to Solidity's `int120` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 120 bits\n     */\n    function toInt120(int256 value) internal pure returns (int120 downcasted) {\n        downcasted = int120(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(120, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int112 from int256, reverting on\n     * overflow (when the input is less than smallest int112 or\n     * greater than largest int112).\n     *\n     * Counterpart to Solidity's `int112` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 112 bits\n     */\n    function toInt112(int256 value) internal pure returns (int112 downcasted) {\n        downcasted = int112(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(112, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int104 from int256, reverting on\n     * overflow (when the input is less than smallest int104 or\n     * greater than largest int104).\n     *\n     * Counterpart to Solidity's `int104` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 104 bits\n     */\n    function toInt104(int256 value) internal pure returns (int104 downcasted) {\n        downcasted = int104(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(104, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int96 from int256, reverting on\n     * overflow (when the input is less than smallest int96 or\n     * greater than largest int96).\n     *\n     * Counterpart to Solidity's `int96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     */\n    function toInt96(int256 value) internal pure returns (int96 downcasted) {\n        downcasted = int96(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(96, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int88 from int256, reverting on\n     * overflow (when the input is less than smallest int88 or\n     * greater than largest int88).\n     *\n     * Counterpart to Solidity's `int88` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 88 bits\n     */\n    function toInt88(int256 value) internal pure returns (int88 downcasted) {\n        downcasted = int88(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(88, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int80 from int256, reverting on\n     * overflow (when the input is less than smallest int80 or\n     * greater than largest int80).\n     *\n     * Counterpart to Solidity's `int80` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 80 bits\n     */\n    function toInt80(int256 value) internal pure returns (int80 downcasted) {\n        downcasted = int80(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(80, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int72 from int256, reverting on\n     * overflow (when the input is less than smallest int72 or\n     * greater than largest int72).\n     *\n     * Counterpart to Solidity's `int72` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 72 bits\n     */\n    function toInt72(int256 value) internal pure returns (int72 downcasted) {\n        downcasted = int72(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(72, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int64 from int256, reverting on\n     * overflow (when the input is less than smallest int64 or\n     * greater than largest int64).\n     *\n     * Counterpart to Solidity's `int64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     */\n    function toInt64(int256 value) internal pure returns (int64 downcasted) {\n        downcasted = int64(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(64, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int56 from int256, reverting on\n     * overflow (when the input is less than smallest int56 or\n     * greater than largest int56).\n     *\n     * Counterpart to Solidity's `int56` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 56 bits\n     */\n    function toInt56(int256 value) internal pure returns (int56 downcasted) {\n        downcasted = int56(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(56, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int48 from int256, reverting on\n     * overflow (when the input is less than smallest int48 or\n     * greater than largest int48).\n     *\n     * Counterpart to Solidity's `int48` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 48 bits\n     */\n    function toInt48(int256 value) internal pure returns (int48 downcasted) {\n        downcasted = int48(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(48, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int40 from int256, reverting on\n     * overflow (when the input is less than smallest int40 or\n     * greater than largest int40).\n     *\n     * Counterpart to Solidity's `int40` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 40 bits\n     */\n    function toInt40(int256 value) internal pure returns (int40 downcasted) {\n        downcasted = int40(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(40, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int32 from int256, reverting on\n     * overflow (when the input is less than smallest int32 or\n     * greater than largest int32).\n     *\n     * Counterpart to Solidity's `int32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     */\n    function toInt32(int256 value) internal pure returns (int32 downcasted) {\n        downcasted = int32(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(32, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int24 from int256, reverting on\n     * overflow (when the input is less than smallest int24 or\n     * greater than largest int24).\n     *\n     * Counterpart to Solidity's `int24` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 24 bits\n     */\n    function toInt24(int256 value) internal pure returns (int24 downcasted) {\n        downcasted = int24(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(24, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int16 from int256, reverting on\n     * overflow (when the input is less than smallest int16 or\n     * greater than largest int16).\n     *\n     * Counterpart to Solidity's `int16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     */\n    function toInt16(int256 value) internal pure returns (int16 downcasted) {\n        downcasted = int16(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(16, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int8 from int256, reverting on\n     * overflow (when the input is less than smallest int8 or\n     * greater than largest int8).\n     *\n     * Counterpart to Solidity's `int8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits\n     */\n    function toInt8(int256 value) internal pure returns (int8 downcasted) {\n        downcasted = int8(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(8, value);\n        }\n    }\n\n    /**\n     * @dev Converts an unsigned uint256 into a signed int256.\n     *\n     * Requirements:\n     *\n     * - input must be less than or equal to maxInt256.\n     */\n    function toInt256(uint256 value) internal pure returns (int256) {\n        // Note: Unsafe cast below is okay because `type(int256).max` is guaranteed to be positive\n        if (value > uint256(type(int256).max)) {\n            revert SafeCastOverflowedUintToInt(value);\n        }\n        return int256(value);\n    }\n\n    /**\n     * @dev Cast a boolean (false or true) to a uint256 (0 or 1) with no jump.\n     */\n    function toUint(bool b) internal pure returns (uint256 u) {\n        assembly (\"memory-safe\") {\n            u := iszero(iszero(b))\n        }\n    }\n}\n"},"lib/cash/src/interfaces/IGeneralManager/IGeneralManagerEvents.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.24;\n\n/**\n * @title IGeneralManagerEvents\n * @author @SocksNFlops\n * @notice Events emitted by the GeneralManager contract\n */\ninterface IGeneralManagerEvents {\n  /**\n   * @notice Emitted when the penalty rate is set\n   * @param oldPenaltyRate The old penalty rate\n   * @param newPenaltyRate The new penalty rate\n   */\n  event PenaltyRateSet(uint16 oldPenaltyRate, uint16 newPenaltyRate);\n\n  /**\n   * @notice Emitted when the refinance rate is set\n   * @param oldRefinanceRate The old refinance rate\n   * @param newRefinanceRate The new refinance rate\n   */\n  event RefinanceRateSet(uint16 oldRefinanceRate, uint16 newRefinanceRate);\n\n  /**\n   * @notice Emitted when the insurance fund address is set\n   * @param oldInsuranceFund The old insurance fund address\n   * @param newInsuranceFund The new insurance fund address\n   */\n  event InsuranceFundSet(address oldInsuranceFund, address newInsuranceFund);\n\n  /**\n   * @notice Emitted when the interest rate oracle address is set\n   * @param oldInterestRateOracle The old interest rate oracle address\n   * @param newInterestRateOracle The new interest rate oracle address\n   */\n  event InterestRateOracleSet(address oldInterestRateOracle, address newInterestRateOracle);\n\n  /**\n   * @notice Emitted when the conversion premium rate is set\n   * @param oldConversionPremiumRate The old conversion premium rate\n   * @param newConversionPremiumRate The new conversion premium rate\n   */\n  event ConversionPremiumRateSet(uint16 oldConversionPremiumRate, uint16 newConversionPremiumRate);\n\n  /**\n   * @notice Emitted when the origination pool scheduler address is set\n   * @param oldOriginationPoolScheduler The old origination pool scheduler address\n   * @param newOriginationPoolScheduler The new origination pool scheduler address\n   */\n  event OriginationPoolSchedulerSet(address oldOriginationPoolScheduler, address newOriginationPoolScheduler);\n\n  /**\n   * @notice Emitted when the loan manager address is set\n   * @param oldLoanManager The old loan manager address\n   * @param newLoanManager The new loan manager address\n   */\n  event LoanManagerSet(address oldLoanManager, address newLoanManager);\n\n  /**\n   * @notice Emitted when the order pool address is set\n   * @param oldOrderPool The old order pool address\n   * @param newOrderPool The new order pool address\n   */\n  event OrderPoolSet(address oldOrderPool, address newOrderPool);\n\n  /**\n   * @notice Emitted when the supported mortgage period terms are updated\n   * @param collateral The address of the collateral\n   * @param mortgagePeriods The mortgage period\n   * @param isSupported Whether the mortgage period terms are supported\n   */\n  event SupportedMortgagePeriodTermsUpdated(address indexed collateral, uint8 mortgagePeriods, bool isSupported);\n\n  /**\n   * @notice Emitted when a price oracle is set\n   * @param collateral The address of the collateral\n   * @param priceOracle The address of the new oracle\n   */\n  event PriceOracleSet(address indexed collateral, address indexed priceOracle);\n\n  /**\n   * @notice Emitted when the minimum cap for a collateral is set\n   * @param collateral The address of the collateral\n   * @param minimumCap The minimum cap\n   */\n  event MinimumCapSet(address indexed collateral, uint256 minimumCap);\n\n  /**\n   * @notice Emitted when the maximum cap for a collateral is set\n   * @param collateral The address of the collateral\n   * @param maximumCap The maximum cap\n   */\n  event MaximumCapSet(address indexed collateral, uint256 maximumCap);\n\n  /**\n   * @notice Emitted when the price spread is set\n   * @param oldPriceSpread The old price spread\n   * @param newPriceSpread The new price spread\n   */\n  event PriceSpreadSet(uint16 oldPriceSpread, uint16 newPriceSpread);\n}\n"},"lib/cash/src/interfaces/IGeneralManager/IGeneralManagerErrors.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.24;\n\nimport {CreationRequest} from \"../../types/orders/OrderRequests.sol\";\n\n/**\n * @title IGeneralManagerErrors\n * @author @SocksNFlops\n * @notice Errors emitted by the GeneralManager contract\n */\ninterface IGeneralManagerErrors {\n  /**\n   * @notice The origination pool is not registered with the scheduler\n   * @param originationPool The address of the origination pool\n   */\n  error InvalidOriginationPool(address originationPool);\n\n  /**\n   * @notice The origination pools array is empty\n   */\n  error EmptyOriginationPools();\n\n  /**\n   * @notice Duplicate origination pools provided in request\n   * @param originationPool The address of the origination pool\n   */\n  error DuplicateOriginationPool(address originationPool);\n\n  /**\n   * @notice The subConsol is not backed by the collateral or is not supported by the consol\n   * @param collateral The address of the collateral\n   * @param subConsol The address of the subConsol\n   * @param consol The address of the consol\n   */\n  error InvalidSubConsol(address collateral, address subConsol, address consol);\n\n  /**\n   * @notice The total periods exceed the maximum possible number of periods\n   * @param totalPeriods The total periods\n   * @param maxTotalPeriods The maximum possible number of periods\n   */\n  error TotalPeriodsExceedsMaximum(uint8 totalPeriods, uint8 maxTotalPeriods);\n\n  /**\n   * @notice The total periods are invalid\n   * @param collateral The address of the collateral\n   * @param totalPeriods The total periods\n   */\n  error InvalidTotalPeriods(address collateral, uint8 totalPeriods);\n\n  /**\n   * @notice The origination pools list length does not match the collateral amounts list length\n   * @param originationPoolsListLength The length of the origination pools list\n   * @param collateralAmountsListLength The length of the collateral amounts list\n   */\n  error OriginationPoolsListLengthMismatch(uint256 originationPoolsListLength, uint256 collateralAmountsListLength);\n\n  /**\n   * @notice The caller is not the order pool\n   * @param caller The address of the caller\n   * @param orderPool The address of the order pool\n   */\n  error OnlyOrderPool(address caller, address orderPool);\n\n  /**\n   * @notice The conversion queue is not registered\n   * @param conversionQueue The address of the conversion queue\n   */\n  error InvalidConversionQueue(address conversionQueue);\n\n  /**\n   * @notice The mortgage is already enqueued in the conversion queue\n   * @param tokenId The tokenId of the mortgage\n   * @param conversionQueue The address of the conversion queue\n   */\n  error MortgageAlreadyEnqueuedInConversionQueue(uint256 tokenId, address conversionQueue);\n\n  /**\n   * @notice Thrown when the caller is not the owner of the mortgageNFT\n   * @param caller The caller of the function\n   * @param owner The owner of the mortgageNFT\n   * @param tokenId The tokenId of the mortgageNFT\n   */\n  error NotMortgageOwner(address caller, address owner, uint256 tokenId);\n\n  /**\n   * @notice Thrown when a compounding mortgage is being created and a conversion queue is not provided\n   * @param creationRequest The create request\n   */\n  error CompoundingMustConvert(CreationRequest creationRequest);\n\n  /**\n   * @notice Thrown when a non-compounding mortgage is being created and the hasPaymentPlan flag is not set to true\n   * @param creationRequest The create request\n   */\n  error NonCompoundingMustHavePaymentPlan(CreationRequest creationRequest);\n\n  /**\n   * @notice Thrown when the total periods of the expansion request does not match the existing mortgage position\n   * @param totalPeriods The total periods of the expansion request\n   * @param existingTotalPeriods The total periods of the existing mortgage position\n   */\n  error ExpansionTotalPeriodsMismatch(uint8 totalPeriods, uint8 existingTotalPeriods);\n\n  /**\n   * @notice Thrown when the amount borrowed is below the minimum cap for the collateral\n   * @param collateral The address of the collateral\n   * @param amountBorrowed The amount borrowed\n   * @param minimumCap The minimum cap\n   */\n  error MinimumCapNotMet(address collateral, uint256 amountBorrowed, uint256 minimumCap);\n\n  /**\n   * @notice Thrown when the amount borrowed is above the maximum cap for the collateral\n   * @param collateral The address of the collateral\n   * @param amountBorrowed The amount borrowed\n   * @param maximumCap The maximum cap\n   */\n  error MaximumCapExceeded(address collateral, uint256 amountBorrowed, uint256 maximumCap);\n\n  /**\n   * @notice Thrown when the caller sends too little gas to the contract\n   * @param sentGas The amount of gas sent\n   * @param requiredGas The required gas\n   */\n  error InsufficientGas(uint256 sentGas, uint256 requiredGas);\n\n  /**\n   * @notice Failed Withdraw Native Gas.\n   * @param amount The amount of native gas to withdraw\n   */\n  error FailedToWithdrawNativeGas(uint256 amount);\n}\n"},"lib/cash/src/types/MortgagePosition.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.20;\n\nimport {MortgageStatus} from \"./enums/MortgageStatus.sol\";\n\n/**\n * @notice The complete state of a mortgage position\n * @param tokenId Numerical identifier for the mortgage\n * @param collateral The address of the collateral token\n * @param collateralDecimals The decimals of the collateral token\n * @param collateralAmount The amount of collateral escrowed in the Consol contract\n * @param collateralConverted The amount of collateral that has been withdrawn as a result of a conversion\n * @param subConsol The address of the SubConsol contract holding the collateral\n * @param interestRate The interest rate of the mortgage, determined at time of initialization\n * @param conversionPremiumRate The rate at which the value of the collateral must grow before being convertible.\n * @param dateOriginated The date the mortgage was originated\n * @param termOriginated The beginning of the term of the mortgage. Will differ from `dateOriginated` if the mortgage is refinanced.\n * @param termBalance The total balance of the mortgage for the current term.\n * @param amountBorrowed The amount borrowed by the borrower\n * @param amountPrior The cumulative amount of principal paid off in prior terms\n * @param termPaid The amount paid by the borrower for the current term\n * @param termConverted The amount of the current term paid via conversion in the current term.\n * @param amountConverted The amount of the principal that has been forgiven as a result of a conversion in previous terms. Excludes the current term.\n * @param penaltyAccrued Sum of penalties accrued. This number is never decremented.\n * @param penaltyPaid The penalty paid by the borrower. Incremented with every call to penaltyPay()\n * @param paymentsMissed The number of payments missed by the borrower. It records the number of penalties that have already been applied. Reset to 0 when mortgage is paid in full.\n * @param totalPeriods The total number of periods that the mortgage will last\n * @param hasPaymentPlan Whether the mortgage has a payment plan\n * @param status The status of the mortgage\n */\nstruct MortgagePosition {\n  uint256 tokenId;\n  address collateral;\n  uint8 collateralDecimals;\n  uint256 collateralAmount;\n  uint256 collateralConverted;\n  address subConsol;\n  uint16 interestRate;\n  uint16 conversionPremiumRate;\n  uint32 dateOriginated;\n  uint32 termOriginated;\n  uint256 termBalance;\n  uint256 amountBorrowed;\n  uint256 amountPrior; // This one is cumulative amounts of principal paid off in prior terms\n  uint256 termPaid; // This one is only for the current term\n  uint256 termConverted; // This is only for the current term\n  uint256 amountConverted; // This one is cumulative amounts of principal converted in previous terms\n  uint256 penaltyAccrued;\n  uint256 penaltyPaid;\n  uint8 paymentsMissed;\n  uint8 totalPeriods;\n  bool hasPaymentPlan;\n  MortgageStatus status;\n}\n"},"lib/cash/src/types/orders/OrderRequests.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.0;\n\n/**\n * @notice The base parameters required for a creating a mortgage or expanding the balance sheet of a mortgage\n * @param collateralAmounts The amounts of collateral to borrow against for each origination pool. This will be escrowed in the Consol contract.\n * @param totalPeriods The total number of periods that the mortgage will last\n * @param originationPools The addresses of the origination pools to use\n * @param isCompounding Whether the mortgage is compounding\n * @param expiration The expiration of the mortgage\n */\nstruct BaseRequest {\n  uint256[] collateralAmounts;\n  uint8 totalPeriods;\n  address[] originationPools;\n  bool isCompounding;\n  uint256 expiration;\n}\n\n/**\n * @notice The parameters required for a creating a mortgage request\n * @param base The base parameters required for a creating a mortgage\n * @param mortgageId The mortgageId of the mortgage NFT to be created\n * @param collateral The address of the collateral token\n * @param subConsol The address of the SubConsol contract holding the collateral\n * @param conversionQueues The addresses of the conversion queues to use. Ignored in expansion requests.\n * @param hasPaymentPlan Whether the mortgage is hasPaymentPlan (periodic payment plan vs single payment)\n */\nstruct CreationRequest {\n  BaseRequest base;\n  string mortgageId;\n  address collateral;\n  address subConsol;\n  address[] conversionQueues;\n  bool hasPaymentPlan;\n}\n\n/**\n * @notice The parameters required for a request to expand the balance of a mortgage\n * @param base The base parameters required for a request to expand the balance of a mortgage\n * @param tokenId The tokenId of the mortgage NFT to be expanded\n */\nstruct ExpansionRequest {\n  BaseRequest base;\n  uint256 tokenId;\n}\n"},"lib/cash/src/interfaces/IOriginationPoolDeployCallback.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.20;\n\n/**\n * @title IOriginationPoolDeployCallback\n * @author SocksNFlops\n * @notice Any contract that calls IOriginationPool#deploy must implement this interface\n */\ninterface IOriginationPoolDeployCallback {\n  /**\n   * @notice Called to `msg.sender` after transferring to the recipient from IOriginationPool#deploy.\n   * @dev In the implementation you must repay the pool the tokens sent by flash after the pool multiplier has been applied.\n   * @param amount The amount of consol sent to the callback\n   * @param returnAmount The amount of consol to return to the origination pool\n   * @param data Any data passed through by the caller via the IOriginationPool#deploy call\n   */\n  function originationPoolDeployCallback(uint256 amount, uint256 returnAmount, bytes calldata data) external;\n}\n"},"lib/cash/src/types/orders/OriginationParameters.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.0;\n\nimport {MortgageParams} from \"../orders/MortgageParams.sol\";\n\n/**\n * @notice The parameters for originating a mortgage creation or balance sheet expansion\n * @param mortgageParams The parameters for the mortgage\n * @param fulfiller The address of the fulfiller\n * @param originationPools The addresses of the origination pools to deploy funds from\n * @param borrowAmounts The amounts being borrowed from each origination pool. Sum must be equal to mortgageParams.amountBorrowed\n * @param conversionQueues The addresses of the conversion queues to use\n * @param hintPrevIds The hintPrevIds of the mortgage\n * @param expansion Whether the mortgage is a balance sheet expansion of an existing position\n * @param purchaseAmount The amount of USDX to purchase\n */\nstruct OriginationParameters {\n  MortgageParams mortgageParams;\n  address fulfiller;\n  address[] originationPools;\n  uint256[] borrowAmounts;\n  address[] conversionQueues;\n  uint256[] hintPrevIds;\n  bool expansion;\n  uint256 purchaseAmount;\n}\n"},"lib/cash/src/interfaces/IPausable/IPausable.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.20;\n\nimport {IPausableErrors} from \"./IPausableErrors.sol\";\n\n/**\n * @title IPausable\n * @author @SocksNFlops\n * @notice Interface for the pausable contract\n */\ninterface IPausable is IPausableErrors {\n  /**\n   * @notice Pause or unpause the contract\n   * @param pause The new paused state\n   */\n  function setPaused(bool pause) external;\n\n  /**\n   * @notice Get the paused state of the contract\n   * @return The paused state of the contract\n   */\n  function paused() external view returns (bool);\n}\n"},"lib/cash/src/interfaces/IOriginationPool/IOriginationPoolEvents.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.20;\n\n/**\n * @title IOriginationPoolEvents\n * @author SocksNFlops\n * @notice Events for the OriginationPool contract\n */\ninterface IOriginationPoolEvents {\n  /**\n   * @notice Event for a deposit\n   * @param user The user\n   * @param token The token\n   * @param amount The amount of USDTokens being deposited\n   * @param mintAmount The amount of OriginationPool tokens being minted\n   */\n  event Deposit(address indexed user, address indexed token, uint256 amount, uint256 mintAmount);\n\n  /**\n   * @notice Event for a deploy\n   * @param user The user\n   * @param token The token\n   * @param amount The amount of USDTokens being deployed\n   * @param receiptAmount The amount of OriginationPool tokens being returned\n   */\n  event Deploy(address indexed user, address indexed token, uint256 amount, uint256 receiptAmount);\n\n  /**\n   * @notice Event for a redeem\n   * @param user The user\n   * @param amount The amount of OriginationPool tokens being redeemed\n   */\n  event Redeem(address indexed user, uint256 amount);\n}\n"},"lib/cash/src/interfaces/IOriginationPool/IOriginationPoolErrors.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.20;\n\nimport {OriginationPoolPhase} from \"../../types/enums/OriginationPoolPhase.sol\";\n\n/**\n * @title IOriginationPoolErrors\n * @author SocksNFlops\n * @notice Errors for the OriginationPool contract\n */\ninterface IOriginationPoolErrors {\n  /**\n   * @notice Error for incorrect phase\n   * @param requiredPhase The required phase\n   * @param currentPhase The current phase\n   */\n  error IncorrectPhase(OriginationPoolPhase requiredPhase, OriginationPoolPhase currentPhase);\n\n  /**\n   * @notice Error for pool limit exceeded\n   * @param poolLimit The pool limit\n   * @param amount The amount\n   */\n  error PoolLimitExceeded(uint256 poolLimit, uint256 amount);\n\n  /**\n   * @notice Error for insufficient consol returned\n   * @param requiredAmount The required amount\n   * @param amountReturned The amount returned\n   */\n  error InsufficientConsolReturned(uint256 requiredAmount, uint256 amountReturned);\n\n  /**\n   * @notice Error for insufficient amount passed to a function\n   * @param amount The amount\n   * @param minimumAmount The minimum amount\n   */\n  error InsufficientAmount(uint256 amount, uint256 minimumAmount);\n}\n"},"lib/cash/src/types/enums/OriginationPoolPhase.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.20;\n\n/**\n * @notice The phases of the Origination Pool\n */\nenum OriginationPoolPhase {\n  /// @notice Lenders can deposit funds into the pool to provide liquidity for mortgage origination\n  DEPOSIT,\n  /// @notice Pool funds are actively deployed for mortgage origination and new deposits/withdrawals are disabled\n  DEPLOY,\n  /// @notice Lenders can redeem their funds from the pool along with earned fees from mortgage originations\n  REDEMPTION\n}\n"},"lib/cash/src/interfaces/IOriginationPoolScheduler/IOriginationPoolSchedulerEvents.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.20;\n\nimport {OPoolConfigId} from \"../../types/OPoolConfigId.sol\";\nimport {OriginationPoolConfig} from \"../../types/OriginationPoolConfig.sol\";\n\ninterface IOriginationPoolSchedulerEvents {\n  /**\n   * @notice Emitted when a new origination pool config is added\n   * @param oPoolConfigId The ID of the origination pool config\n   * @param oPoolConfig The origination pool config\n   */\n  event OriginationPoolConfigAdded(OPoolConfigId oPoolConfigId, OriginationPoolConfig oPoolConfig);\n\n  /**\n   * @notice Emitted when an origination pool config is removed\n   * @param oPoolConfigId The ID of the origination pool config\n   * @param oPoolConfig The origination pool config\n   */\n  event OriginationPoolConfigRemoved(OPoolConfigId oPoolConfigId, OriginationPoolConfig oPoolConfig);\n\n  /**\n   * @notice Emitted when an origination pool is deployed\n   * @param oPoolConfigId The ID of the origination pool config\n   * @param oPoolConfig The origination pool config\n   * @param deploymentAddress The address of the deployment\n   * @param deploymentEpoch The epoch of the deployment\n   * @param deploymentTimestamp The timestamp of the deployment\n   */\n  event OriginationPoolDeployed(\n    OPoolConfigId indexed oPoolConfigId,\n    OriginationPoolConfig indexed oPoolConfig,\n    address indexed deploymentAddress,\n    uint256 deploymentEpoch,\n    uint256 deploymentTimestamp\n  );\n\n  /**\n   * @notice Emitted when an origination pool is updated\n   * @param originationPool The address of the origination pool\n   * @param registered Whether the origination pool is registered\n   */\n  event OriginationPoolRegistryUpdated(address indexed originationPool, bool registered);\n}\n"},"lib/cash/src/interfaces/IOriginationPoolScheduler/IOriginationPoolSchedulerErrors.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.20;\n\nimport {OriginationPoolConfig} from \"../../types/OriginationPoolConfig.sol\";\nimport {OPoolConfigId} from \"../../types/OPoolConfigId.sol\";\n\ninterface IOriginationPoolSchedulerErrors {\n  /**\n   * @notice The new admin does not have the DEFAULT_ADMIN_ROLE\n   * @param newOpoolAdmin The address of the new admin\n   */\n  error InvalidOpoolAdmin(address newOpoolAdmin);\n\n  /**\n   * @notice The origination pool config already exists\n   * @param oPoolConfig The origination pool config that already exists\n   */\n  error OriginationPoolConfigAlreadyExists(OriginationPoolConfig oPoolConfig);\n\n  /**\n   * @notice The origination pool config does not exist\n   * @param oPoolConfig The origination pool config that does not exist\n   */\n  error OriginationPoolConfigDoesNotExist(OriginationPoolConfig oPoolConfig);\n\n  /**\n   * @notice The origination pool config is invalid\n   * @param oPoolConfig The origination pool config that is invalid\n   */\n  error InvalidOriginationPoolConfig(OriginationPoolConfig oPoolConfig);\n\n  /**\n   * @notice The origination pool has already been deployed this epoch\n   * @param oPoolConfig The origination pool config\n   * @param deploymentAddress The address of the deployment\n   * @param deploymentEpoch The epoch of the deployment\n   * @param deploymentTimestamp The timestamp of the deployment\n   */\n  error OriginationPoolAlreadyDeployedThisEpoch(\n    OriginationPoolConfig oPoolConfig, address deploymentAddress, uint256 deploymentEpoch, uint256 deploymentTimestamp\n  );\n\n  /**\n   * @notice The origination pool config id does not exist\n   * @param oPoolConfigId The origination pool config id that does not exist\n   */\n  error OriginationPoolConfigIdDoesNotExist(OPoolConfigId oPoolConfigId);\n}\n"},"lib/cash/src/types/OriginationPoolConfig.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.0;\n\nimport {OPoolConfigIdLibrary} from \"./OPoolConfigId.sol\";\n\nusing OPoolConfigIdLibrary for OriginationPoolConfig global;\n\n/**\n * @notice The configuration for a recurring origination pool deployment\n * @param namePrefix The prefix for the name of the pool\n * @param symbolPrefix The prefix for the symbol of the pool\n * @param consol The consol token for the pool\n * @param usdx The USDX token for the pool\n * @param depositPhaseDuration The duration of the deposit phase\n * @param deployPhaseDuration The duration of the deploy phase\n * @param defaultPoolLimit The starting pool limit (for first deployment)\n * @param poolLimitGrowthRateBps The rate at which the pool limit grows each epoch if the previous pool limit was reached\n * @param poolMultiplierBps The pool multiplier in basis points\n */\nstruct OriginationPoolConfig {\n  string namePrefix;\n  string symbolPrefix;\n  address consol;\n  address usdx;\n  uint32 depositPhaseDuration;\n  uint32 deployPhaseDuration;\n  uint256 defaultPoolLimit;\n  uint16 poolLimitGrowthRateBps;\n  uint16 poolMultiplierBps;\n}\n"},"lib/cash/src/types/OPoolConfigId.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.0;\n\nimport {OriginationPoolConfig} from \"./OriginationPoolConfig.sol\";\n\ntype OPoolConfigId is bytes32;\n\n/**\n * @title OPoolConfigIdLibrary\n * @author SocksNFlops\n * @notice Library for computing the ID of a origination pool config\n */\nlibrary OPoolConfigIdLibrary {\n  /**\n   * @dev Returns value equal to keccak256(abi.encode(OPoolConfig))\n   * @param oPoolConfig The origination pool config to compute the ID for\n   * @return oPoolConfigId The ID of the origination pool config\n   */\n  function toId(OriginationPoolConfig memory oPoolConfig) internal pure returns (OPoolConfigId oPoolConfigId) {\n    return OPoolConfigId.wrap(keccak256(abi.encode(oPoolConfig)));\n  }\n}\n"},"src/interfaces/ILiquidityVault/ILiquidityVaultEvents.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.20;\n\n/**\n * @title ILiquidityVaultEvents\n * @author @SocksNFlops\n * @notice Interface for events emitted by LiquidityVaults.\n */\ninterface ILiquidityVaultEvents {\n  /**\n   * @notice Emitted when a user deposits assets into the vault.\n   * @param user The address of the user who deposited the assets.\n   * @param depositableAsset The address of the depositable asset.\n   * @param amountDeposited The amount of depositable asset sent.\n   * @param sharesMinted The amount of shares minted.\n   */\n  event Deposited(\n    address indexed user, address indexed depositableAsset, uint256 amountDeposited, uint256 sharesMinted\n  );\n\n  /**\n   * @notice Emitted when a user redeems assets from the vault.\n   * @param user The address of the user who redeemed the assets.\n   * @param redeemableAssets The addresses of the redeemable assets.\n   * @param amountsRedeemed The amounts of redeemable assets received.\n   * @param sharesBurned The amount of shares burned.\n   */\n  event Redeemed(\n    address indexed user, address[] indexed redeemableAssets, uint256[] amountsRedeemed, uint256 sharesBurned\n  );\n\n  /**\n   * @notice Emitted when the whitelist is enforced.\n   * @param enforced Whether the whitelist is enforced.\n   */\n  event WhitelistEnforced(bool enforced);\n\n  /**\n   * @notice Emitted when the redeemable assets are updated.\n   * @param redeemableAssets The addresses of the redeemable assets.\n   */\n  event RedeemableAssetsUpdated(address[] indexed redeemableAssets);\n\n  /**\n   * @notice Emitted when the depositable assets are updated.\n   * @param depositableAssets The addresses of the depositable assets.\n   */\n  event DepositableAssetsUpdated(address[] indexed depositableAssets);\n}\n"},"src/interfaces/ILiquidityVault/ILiquidityVaultErrors.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.20;\n\n/**\n * @title ILiquidityVaultErrors\n * @author @SocksNFlops\n * @notice Interface for errors emitted by LiquidityVaults.\n */\ninterface ILiquidityVaultErrors {\n  /**\n   * @notice Thrown when the depositable asset is not in the depositable assets list\n   * @param asset The address of the asset that is not depositable\n   */\n  error AssetNotDepositable(address asset);\n}\n"},"lib/openzeppelin-contracts-upgradeable/contracts/utils/ContextUpgradeable.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\n\npragma solidity ^0.8.20;\nimport {Initializable} from \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract ContextUpgradeable is Initializable {\n    function __Context_init() internal onlyInitializing {\n    }\n\n    function __Context_init_unchained() internal onlyInitializing {\n    }\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n"},"lib/openzeppelin-contracts/contracts/interfaces/draft-IERC6093.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (interfaces/draft-IERC6093.sol)\npragma solidity >=0.8.4;\n\n/**\n * @dev Standard ERC-20 Errors\n * Interface of the https://eips.ethereum.org/EIPS/eip-6093[ERC-6093] custom errors for ERC-20 tokens.\n */\ninterface IERC20Errors {\n    /**\n     * @dev Indicates an error related to the current `balance` of a `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     * @param balance Current balance for the interacting account.\n     * @param needed Minimum amount required to perform a transfer.\n     */\n    error ERC20InsufficientBalance(address sender, uint256 balance, uint256 needed);\n\n    /**\n     * @dev Indicates a failure with the token `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     */\n    error ERC20InvalidSender(address sender);\n\n    /**\n     * @dev Indicates a failure with the token `receiver`. Used in transfers.\n     * @param receiver Address to which tokens are being transferred.\n     */\n    error ERC20InvalidReceiver(address receiver);\n\n    /**\n     * @dev Indicates a failure with the `spender`’s `allowance`. Used in transfers.\n     * @param spender Address that may be allowed to operate on tokens without being their owner.\n     * @param allowance Amount of tokens a `spender` is allowed to operate with.\n     * @param needed Minimum amount required to perform a transfer.\n     */\n    error ERC20InsufficientAllowance(address spender, uint256 allowance, uint256 needed);\n\n    /**\n     * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.\n     * @param approver Address initiating an approval operation.\n     */\n    error ERC20InvalidApprover(address approver);\n\n    /**\n     * @dev Indicates a failure with the `spender` to be approved. Used in approvals.\n     * @param spender Address that may be allowed to operate on tokens without being their owner.\n     */\n    error ERC20InvalidSpender(address spender);\n}\n\n/**\n * @dev Standard ERC-721 Errors\n * Interface of the https://eips.ethereum.org/EIPS/eip-6093[ERC-6093] custom errors for ERC-721 tokens.\n */\ninterface IERC721Errors {\n    /**\n     * @dev Indicates that an address can't be an owner. For example, `address(0)` is a forbidden owner in ERC-20.\n     * Used in balance queries.\n     * @param owner Address of the current owner of a token.\n     */\n    error ERC721InvalidOwner(address owner);\n\n    /**\n     * @dev Indicates a `tokenId` whose `owner` is the zero address.\n     * @param tokenId Identifier number of a token.\n     */\n    error ERC721NonexistentToken(uint256 tokenId);\n\n    /**\n     * @dev Indicates an error related to the ownership over a particular token. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     * @param tokenId Identifier number of a token.\n     * @param owner Address of the current owner of a token.\n     */\n    error ERC721IncorrectOwner(address sender, uint256 tokenId, address owner);\n\n    /**\n     * @dev Indicates a failure with the token `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     */\n    error ERC721InvalidSender(address sender);\n\n    /**\n     * @dev Indicates a failure with the token `receiver`. Used in transfers.\n     * @param receiver Address to which tokens are being transferred.\n     */\n    error ERC721InvalidReceiver(address receiver);\n\n    /**\n     * @dev Indicates a failure with the `operator`’s approval. Used in transfers.\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\n     * @param tokenId Identifier number of a token.\n     */\n    error ERC721InsufficientApproval(address operator, uint256 tokenId);\n\n    /**\n     * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.\n     * @param approver Address initiating an approval operation.\n     */\n    error ERC721InvalidApprover(address approver);\n\n    /**\n     * @dev Indicates a failure with the `operator` to be approved. Used in approvals.\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\n     */\n    error ERC721InvalidOperator(address operator);\n}\n\n/**\n * @dev Standard ERC-1155 Errors\n * Interface of the https://eips.ethereum.org/EIPS/eip-6093[ERC-6093] custom errors for ERC-1155 tokens.\n */\ninterface IERC1155Errors {\n    /**\n     * @dev Indicates an error related to the current `balance` of a `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     * @param balance Current balance for the interacting account.\n     * @param needed Minimum amount required to perform a transfer.\n     * @param tokenId Identifier number of a token.\n     */\n    error ERC1155InsufficientBalance(address sender, uint256 balance, uint256 needed, uint256 tokenId);\n\n    /**\n     * @dev Indicates a failure with the token `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     */\n    error ERC1155InvalidSender(address sender);\n\n    /**\n     * @dev Indicates a failure with the token `receiver`. Used in transfers.\n     * @param receiver Address to which tokens are being transferred.\n     */\n    error ERC1155InvalidReceiver(address receiver);\n\n    /**\n     * @dev Indicates a failure with the `operator`’s approval. Used in transfers.\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\n     * @param owner Address of the current owner of a token.\n     */\n    error ERC1155MissingApprovalForAll(address operator, address owner);\n\n    /**\n     * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.\n     * @param approver Address initiating an approval operation.\n     */\n    error ERC1155InvalidApprover(address approver);\n\n    /**\n     * @dev Indicates a failure with the `operator` to be approved. Used in approvals.\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\n     */\n    error ERC1155InvalidOperator(address operator);\n\n    /**\n     * @dev Indicates an array length mismatch between ids and values in a safeBatchTransferFrom operation.\n     * Used in batch transfers.\n     * @param idsLength Length of the array of token identifiers\n     * @param valuesLength Length of the array of token amounts\n     */\n    error ERC1155InvalidArrayLength(uint256 idsLength, uint256 valuesLength);\n}\n"},"lib/openzeppelin-contracts-upgradeable/contracts/proxy/utils/Initializable.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.3.0) (proxy/utils/Initializable.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\n * reused. This mechanism prevents re-execution of each \"step\" but allows the creation of new initialization steps in\n * case an upgrade adds a module that needs to be initialized.\n *\n * For example:\n *\n * [.hljs-theme-light.nopadding]\n * ```solidity\n * contract MyToken is ERC20Upgradeable {\n *     function initialize() initializer public {\n *         __ERC20_init(\"MyToken\", \"MTK\");\n *     }\n * }\n *\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\n *     function initializeV2() reinitializer(2) public {\n *         __ERC20Permit_init(\"MyToken\");\n *     }\n * }\n * ```\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n *\n * [CAUTION]\n * ====\n * Avoid leaving a contract uninitialized.\n *\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * /// @custom:oz-upgrades-unsafe-allow constructor\n * constructor() {\n *     _disableInitializers();\n * }\n * ```\n * ====\n */\nabstract contract Initializable {\n    /**\n     * @dev Storage of the initializable contract.\n     *\n     * It's implemented on a custom ERC-7201 namespace to reduce the risk of storage collisions\n     * when using with upgradeable contracts.\n     *\n     * @custom:storage-location erc7201:openzeppelin.storage.Initializable\n     */\n    struct InitializableStorage {\n        /**\n         * @dev Indicates that the contract has been initialized.\n         */\n        uint64 _initialized;\n        /**\n         * @dev Indicates that the contract is in the process of being initialized.\n         */\n        bool _initializing;\n    }\n\n    // keccak256(abi.encode(uint256(keccak256(\"openzeppelin.storage.Initializable\")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant INITIALIZABLE_STORAGE = 0xf0c57e16840df040f15088dc2f81fe391c3923bec73e23a9662efc9c229c6a00;\n\n    /**\n     * @dev The contract is already initialized.\n     */\n    error InvalidInitialization();\n\n    /**\n     * @dev The contract is not initializing.\n     */\n    error NotInitializing();\n\n    /**\n     * @dev Triggered when the contract has been initialized or reinitialized.\n     */\n    event Initialized(uint64 version);\n\n    /**\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\n     * `onlyInitializing` functions can be used to initialize parent contracts.\n     *\n     * Similar to `reinitializer(1)`, except that in the context of a constructor an `initializer` may be invoked any\n     * number of times. This behavior in the constructor can be useful during testing and is not expected to be used in\n     * production.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier initializer() {\n        // solhint-disable-next-line var-name-mixedcase\n        InitializableStorage storage $ = _getInitializableStorage();\n\n        // Cache values to avoid duplicated sloads\n        bool isTopLevelCall = !$._initializing;\n        uint64 initialized = $._initialized;\n\n        // Allowed calls:\n        // - initialSetup: the contract is not in the initializing state and no previous version was\n        //                 initialized\n        // - construction: the contract is initialized at version 1 (no reinitialization) and the\n        //                 current contract is just being deployed\n        bool initialSetup = initialized == 0 && isTopLevelCall;\n        bool construction = initialized == 1 && address(this).code.length == 0;\n\n        if (!initialSetup && !construction) {\n            revert InvalidInitialization();\n        }\n        $._initialized = 1;\n        if (isTopLevelCall) {\n            $._initializing = true;\n        }\n        _;\n        if (isTopLevelCall) {\n            $._initializing = false;\n            emit Initialized(1);\n        }\n    }\n\n    /**\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\n     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\n     * used to initialize parent contracts.\n     *\n     * A reinitializer may be used after the original initialization step. This is essential to configure modules that\n     * are added through upgrades and that require initialization.\n     *\n     * When `version` is 1, this modifier is similar to `initializer`, except that functions marked with `reinitializer`\n     * cannot be nested. If one is invoked in the context of another, execution will revert.\n     *\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\n     * a contract, executing them in the right order is up to the developer or operator.\n     *\n     * WARNING: Setting the version to 2**64 - 1 will prevent any future reinitialization.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier reinitializer(uint64 version) {\n        // solhint-disable-next-line var-name-mixedcase\n        InitializableStorage storage $ = _getInitializableStorage();\n\n        if ($._initializing || $._initialized >= version) {\n            revert InvalidInitialization();\n        }\n        $._initialized = version;\n        $._initializing = true;\n        _;\n        $._initializing = false;\n        emit Initialized(version);\n    }\n\n    /**\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\n     */\n    modifier onlyInitializing() {\n        _checkInitializing();\n        _;\n    }\n\n    /**\n     * @dev Reverts if the contract is not in an initializing state. See {onlyInitializing}.\n     */\n    function _checkInitializing() internal view virtual {\n        if (!_isInitializing()) {\n            revert NotInitializing();\n        }\n    }\n\n    /**\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\n     * through proxies.\n     *\n     * Emits an {Initialized} event the first time it is successfully executed.\n     */\n    function _disableInitializers() internal virtual {\n        // solhint-disable-next-line var-name-mixedcase\n        InitializableStorage storage $ = _getInitializableStorage();\n\n        if ($._initializing) {\n            revert InvalidInitialization();\n        }\n        if ($._initialized != type(uint64).max) {\n            $._initialized = type(uint64).max;\n            emit Initialized(type(uint64).max);\n        }\n    }\n\n    /**\n     * @dev Returns the highest version that has been initialized. See {reinitializer}.\n     */\n    function _getInitializedVersion() internal view returns (uint64) {\n        return _getInitializableStorage()._initialized;\n    }\n\n    /**\n     * @dev Returns `true` if the contract is currently initializing. See {onlyInitializing}.\n     */\n    function _isInitializing() internal view returns (bool) {\n        return _getInitializableStorage()._initializing;\n    }\n\n    /**\n     * @dev Pointer to storage slot. Allows integrators to override it with a custom storage location.\n     *\n     * NOTE: Consider following the ERC-7201 formula to derive storage locations.\n     */\n    function _initializableStorageSlot() internal pure virtual returns (bytes32) {\n        return INITIALIZABLE_STORAGE;\n    }\n\n    /**\n     * @dev Returns a pointer to the storage namespace.\n     */\n    // solhint-disable-next-line var-name-mixedcase\n    function _getInitializableStorage() private pure returns (InitializableStorage storage $) {\n        bytes32 slot = _initializableStorageSlot();\n        assembly {\n            $.slot := slot\n        }\n    }\n}\n"},"lib/openzeppelin-contracts/contracts/utils/introspection/IERC165.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (utils/introspection/IERC165.sol)\n\npragma solidity >=0.4.16;\n\n/**\n * @dev Interface of the ERC-165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[ERC].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[ERC section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"},"lib/openzeppelin-contracts/contracts/proxy/ERC1967/ERC1967Utils.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (proxy/ERC1967/ERC1967Utils.sol)\n\npragma solidity ^0.8.21;\n\nimport {IBeacon} from \"../beacon/IBeacon.sol\";\nimport {IERC1967} from \"../../interfaces/IERC1967.sol\";\nimport {Address} from \"../../utils/Address.sol\";\nimport {StorageSlot} from \"../../utils/StorageSlot.sol\";\n\n/**\n * @dev This library provides getters and event emitting update functions for\n * https://eips.ethereum.org/EIPS/eip-1967[ERC-1967] slots.\n */\nlibrary ERC1967Utils {\n    /**\n     * @dev Storage slot with the address of the current implementation.\n     * This is the keccak-256 hash of \"eip1967.proxy.implementation\" subtracted by 1.\n     */\n    // solhint-disable-next-line private-vars-leading-underscore\n    bytes32 internal constant IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n\n    /**\n     * @dev The `implementation` of the proxy is invalid.\n     */\n    error ERC1967InvalidImplementation(address implementation);\n\n    /**\n     * @dev The `admin` of the proxy is invalid.\n     */\n    error ERC1967InvalidAdmin(address admin);\n\n    /**\n     * @dev The `beacon` of the proxy is invalid.\n     */\n    error ERC1967InvalidBeacon(address beacon);\n\n    /**\n     * @dev An upgrade function sees `msg.value > 0` that may be lost.\n     */\n    error ERC1967NonPayable();\n\n    /**\n     * @dev Returns the current implementation address.\n     */\n    function getImplementation() internal view returns (address) {\n        return StorageSlot.getAddressSlot(IMPLEMENTATION_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the ERC-1967 implementation slot.\n     */\n    function _setImplementation(address newImplementation) private {\n        if (newImplementation.code.length == 0) {\n            revert ERC1967InvalidImplementation(newImplementation);\n        }\n        StorageSlot.getAddressSlot(IMPLEMENTATION_SLOT).value = newImplementation;\n    }\n\n    /**\n     * @dev Performs implementation upgrade with additional setup call if data is nonempty.\n     * This function is payable only if the setup call is performed, otherwise `msg.value` is rejected\n     * to avoid stuck value in the contract.\n     *\n     * Emits an {IERC1967-Upgraded} event.\n     */\n    function upgradeToAndCall(address newImplementation, bytes memory data) internal {\n        _setImplementation(newImplementation);\n        emit IERC1967.Upgraded(newImplementation);\n\n        if (data.length > 0) {\n            Address.functionDelegateCall(newImplementation, data);\n        } else {\n            _checkNonPayable();\n        }\n    }\n\n    /**\n     * @dev Storage slot with the admin of the contract.\n     * This is the keccak-256 hash of \"eip1967.proxy.admin\" subtracted by 1.\n     */\n    // solhint-disable-next-line private-vars-leading-underscore\n    bytes32 internal constant ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n\n    /**\n     * @dev Returns the current admin.\n     *\n     * TIP: To get this value clients can read directly from the storage slot shown below (specified by ERC-1967) using\n     * the https://eth.wiki/json-rpc/API#eth_getstorageat[`eth_getStorageAt`] RPC call.\n     * `0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103`\n     */\n    function getAdmin() internal view returns (address) {\n        return StorageSlot.getAddressSlot(ADMIN_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the ERC-1967 admin slot.\n     */\n    function _setAdmin(address newAdmin) private {\n        if (newAdmin == address(0)) {\n            revert ERC1967InvalidAdmin(address(0));\n        }\n        StorageSlot.getAddressSlot(ADMIN_SLOT).value = newAdmin;\n    }\n\n    /**\n     * @dev Changes the admin of the proxy.\n     *\n     * Emits an {IERC1967-AdminChanged} event.\n     */\n    function changeAdmin(address newAdmin) internal {\n        emit IERC1967.AdminChanged(getAdmin(), newAdmin);\n        _setAdmin(newAdmin);\n    }\n\n    /**\n     * @dev The storage slot of the UpgradeableBeacon contract which defines the implementation for this proxy.\n     * This is the keccak-256 hash of \"eip1967.proxy.beacon\" subtracted by 1.\n     */\n    // solhint-disable-next-line private-vars-leading-underscore\n    bytes32 internal constant BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;\n\n    /**\n     * @dev Returns the current beacon.\n     */\n    function getBeacon() internal view returns (address) {\n        return StorageSlot.getAddressSlot(BEACON_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new beacon in the ERC-1967 beacon slot.\n     */\n    function _setBeacon(address newBeacon) private {\n        if (newBeacon.code.length == 0) {\n            revert ERC1967InvalidBeacon(newBeacon);\n        }\n\n        StorageSlot.getAddressSlot(BEACON_SLOT).value = newBeacon;\n\n        address beaconImplementation = IBeacon(newBeacon).implementation();\n        if (beaconImplementation.code.length == 0) {\n            revert ERC1967InvalidImplementation(beaconImplementation);\n        }\n    }\n\n    /**\n     * @dev Change the beacon and trigger a setup call if data is nonempty.\n     * This function is payable only if the setup call is performed, otherwise `msg.value` is rejected\n     * to avoid stuck value in the contract.\n     *\n     * Emits an {IERC1967-BeaconUpgraded} event.\n     *\n     * CAUTION: Invoking this function has no effect on an instance of {BeaconProxy} since v5, since\n     * it uses an immutable beacon without looking at the value of the ERC-1967 beacon slot for\n     * efficiency.\n     */\n    function upgradeBeaconToAndCall(address newBeacon, bytes memory data) internal {\n        _setBeacon(newBeacon);\n        emit IERC1967.BeaconUpgraded(newBeacon);\n\n        if (data.length > 0) {\n            Address.functionDelegateCall(IBeacon(newBeacon).implementation(), data);\n        } else {\n            _checkNonPayable();\n        }\n    }\n\n    /**\n     * @dev Reverts if `msg.value` is not zero. It can be used to avoid `msg.value` stuck in the contract\n     * if an upgrade doesn't perform an initialization call.\n     */\n    function _checkNonPayable() private {\n        if (msg.value > 0) {\n            revert ERC1967NonPayable();\n        }\n    }\n}\n"},"lib/openzeppelin-contracts/contracts/interfaces/IERC1363.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (interfaces/IERC1363.sol)\n\npragma solidity >=0.6.2;\n\nimport {IERC20} from \"./IERC20.sol\";\nimport {IERC165} from \"./IERC165.sol\";\n\n/**\n * @title IERC1363\n * @dev Interface of the ERC-1363 standard as defined in the https://eips.ethereum.org/EIPS/eip-1363[ERC-1363].\n *\n * Defines an extension interface for ERC-20 tokens that supports executing code on a recipient contract\n * after `transfer` or `transferFrom`, or code on a spender contract after `approve`, in a single transaction.\n */\ninterface IERC1363 is IERC20, IERC165 {\n    /*\n     * Note: the ERC-165 identifier for this interface is 0xb0202a11.\n     * 0xb0202a11 ===\n     *   bytes4(keccak256('transferAndCall(address,uint256)')) ^\n     *   bytes4(keccak256('transferAndCall(address,uint256,bytes)')) ^\n     *   bytes4(keccak256('transferFromAndCall(address,address,uint256)')) ^\n     *   bytes4(keccak256('transferFromAndCall(address,address,uint256,bytes)')) ^\n     *   bytes4(keccak256('approveAndCall(address,uint256)')) ^\n     *   bytes4(keccak256('approveAndCall(address,uint256,bytes)'))\n     */\n\n    /**\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`\n     * and then calls {IERC1363Receiver-onTransferReceived} on `to`.\n     * @param to The address which you want to transfer to.\n     * @param value The amount of tokens to be transferred.\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\n     */\n    function transferAndCall(address to, uint256 value) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`\n     * and then calls {IERC1363Receiver-onTransferReceived} on `to`.\n     * @param to The address which you want to transfer to.\n     * @param value The amount of tokens to be transferred.\n     * @param data Additional data with no specified format, sent in call to `to`.\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\n     */\n    function transferAndCall(address to, uint256 value, bytes calldata data) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the allowance mechanism\n     * and then calls {IERC1363Receiver-onTransferReceived} on `to`.\n     * @param from The address which you want to send tokens from.\n     * @param to The address which you want to transfer to.\n     * @param value The amount of tokens to be transferred.\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\n     */\n    function transferFromAndCall(address from, address to, uint256 value) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the allowance mechanism\n     * and then calls {IERC1363Receiver-onTransferReceived} on `to`.\n     * @param from The address which you want to send tokens from.\n     * @param to The address which you want to transfer to.\n     * @param value The amount of tokens to be transferred.\n     * @param data Additional data with no specified format, sent in call to `to`.\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\n     */\n    function transferFromAndCall(address from, address to, uint256 value, bytes calldata data) external returns (bool);\n\n    /**\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\n     * caller's tokens and then calls {IERC1363Spender-onApprovalReceived} on `spender`.\n     * @param spender The address which will spend the funds.\n     * @param value The amount of tokens to be spent.\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\n     */\n    function approveAndCall(address spender, uint256 value) external returns (bool);\n\n    /**\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\n     * caller's tokens and then calls {IERC1363Spender-onApprovalReceived} on `spender`.\n     * @param spender The address which will spend the funds.\n     * @param value The amount of tokens to be spent.\n     * @param data Additional data with no specified format, sent in call to `spender`.\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\n     */\n    function approveAndCall(address spender, uint256 value, bytes calldata data) external returns (bool);\n}\n"},"lib/cash/src/types/enums/MortgageStatus.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.20;\n\n/**\n * @notice The status of a mortgage position\n */\nenum MortgageStatus {\n  /// @notice Mortgage is active and operational, with payments being made according to the payment plan\n  ACTIVE,\n  /// @notice Mortgage has been foreclosed due to excessive missed payments\n  FORECLOSED,\n  /// @notice Mortgage has been fully paid off and redeemed by the borrower, with collateral returned\n  REDEEMED\n}\n"},"lib/cash/src/types/orders/MortgageParams.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.0;\n\n/**\n * @notice The parameters for creating a mortgage position\n * @param owner The address of the owner of the mortgage\n * @param tokenId The tokenId of the mortgage NFT\n * @param collateral The address of the collateral token\n * @param collateralDecimals The decimals of the collateral token\n * @param collateralAmount The amount of collateral escrowed in the Consol contract\n * @param subConsol The address of the SubConsol contract holding the collateral\n * @param interestRate The interest rate of the mortgage\n * @param conversionPremiumRate The rate at which the value of the collateral must grow before being convertible.\n * @param amountBorrowed The total amount being borrowed from all origination pools\n * @param totalPeriods The total umber of periods that the mortgage will last\n * @param hasPaymentPlan Whether the mortgage is hasPaymentPlan (periodic payment plan vs single payment)\n */\nstruct MortgageParams {\n  address owner;\n  uint256 tokenId;\n  address collateral;\n  uint8 collateralDecimals;\n  uint256 collateralAmount;\n  address subConsol;\n  uint16 interestRate;\n  uint16 conversionPremiumRate;\n  uint256 amountBorrowed;\n  uint8 totalPeriods;\n  bool hasPaymentPlan;\n}\n"},"lib/cash/src/interfaces/IPausable/IPausableErrors.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.20;\n\n/**\n * @title IPausableErrors\n * @author @SocksNFlops\n * @notice Errors for the pausable contract\n */\ninterface IPausableErrors {\n  /**\n   * @notice Error for paused pool\n   */\n  error Paused();\n}\n"},"lib/openzeppelin-contracts/contracts/proxy/beacon/IBeacon.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (proxy/beacon/IBeacon.sol)\n\npragma solidity >=0.4.16;\n\n/**\n * @dev This is the interface that {BeaconProxy} expects of its beacon.\n */\ninterface IBeacon {\n    /**\n     * @dev Must return an address that can be used as a delegate call target.\n     *\n     * {UpgradeableBeacon} will check that this address is a contract.\n     */\n    function implementation() external view returns (address);\n}\n"},"lib/openzeppelin-contracts/contracts/interfaces/IERC1967.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (interfaces/IERC1967.sol)\n\npragma solidity >=0.4.11;\n\n/**\n * @dev ERC-1967: Proxy Storage Slots. This interface contains the events defined in the ERC.\n */\ninterface IERC1967 {\n    /**\n     * @dev Emitted when the implementation is upgraded.\n     */\n    event Upgraded(address indexed implementation);\n\n    /**\n     * @dev Emitted when the admin account has changed.\n     */\n    event AdminChanged(address previousAdmin, address newAdmin);\n\n    /**\n     * @dev Emitted when the beacon is changed.\n     */\n    event BeaconUpgraded(address indexed beacon);\n}\n"},"lib/openzeppelin-contracts/contracts/utils/Address.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (utils/Address.sol)\n\npragma solidity ^0.8.20;\n\nimport {Errors} from \"./Errors.sol\";\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev There's no code at `target` (it is not a contract).\n     */\n    error AddressEmptyCode(address target);\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.20/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        if (address(this).balance < amount) {\n            revert Errors.InsufficientBalance(address(this).balance, amount);\n        }\n\n        (bool success, bytes memory returndata) = recipient.call{value: amount}(\"\");\n        if (!success) {\n            _revert(returndata);\n        }\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason or custom error, it is bubbled\n     * up by this function (like regular Solidity function calls). However, if\n     * the call reverted with no returned reason, this function reverts with a\n     * {Errors.FailedCall} error.\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        if (address(this).balance < value) {\n            revert Errors.InsufficientBalance(address(this).balance, value);\n        }\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and reverts if the target\n     * was not a contract or bubbling up the revert reason (falling back to {Errors.FailedCall}) in case\n     * of an unsuccessful call.\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata\n    ) internal view returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            // only check if target is a contract if the call was successful and the return data is empty\n            // otherwise we already know that it was a contract\n            if (returndata.length == 0 && target.code.length == 0) {\n                revert AddressEmptyCode(target);\n            }\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and reverts if it wasn't, either by bubbling the\n     * revert reason or with a default {Errors.FailedCall} error.\n     */\n    function verifyCallResult(bool success, bytes memory returndata) internal pure returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Reverts with returndata if present. Otherwise reverts with {Errors.FailedCall}.\n     */\n    function _revert(bytes memory returndata) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            assembly (\"memory-safe\") {\n                revert(add(returndata, 0x20), mload(returndata))\n            }\n        } else {\n            revert Errors.FailedCall();\n        }\n    }\n}\n"},"lib/openzeppelin-contracts/contracts/utils/StorageSlot.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/StorageSlot.sol)\n// This file was procedurally generated from scripts/generate/templates/StorageSlot.js.\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Library for reading and writing primitive types to specific storage slots.\n *\n * Storage slots are often used to avoid storage conflict when dealing with upgradeable contracts.\n * This library helps with reading and writing to such slots without the need for inline assembly.\n *\n * The functions in this library return Slot structs that contain a `value` member that can be used to read or write.\n *\n * Example usage to set ERC-1967 implementation slot:\n * ```solidity\n * contract ERC1967 {\n *     // Define the slot. Alternatively, use the SlotDerivation library to derive the slot.\n *     bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n *\n *     function _getImplementation() internal view returns (address) {\n *         return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n *     }\n *\n *     function _setImplementation(address newImplementation) internal {\n *         require(newImplementation.code.length > 0);\n *         StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n *     }\n * }\n * ```\n *\n * TIP: Consider using this library along with {SlotDerivation}.\n */\nlibrary StorageSlot {\n    struct AddressSlot {\n        address value;\n    }\n\n    struct BooleanSlot {\n        bool value;\n    }\n\n    struct Bytes32Slot {\n        bytes32 value;\n    }\n\n    struct Uint256Slot {\n        uint256 value;\n    }\n\n    struct Int256Slot {\n        int256 value;\n    }\n\n    struct StringSlot {\n        string value;\n    }\n\n    struct BytesSlot {\n        bytes value;\n    }\n\n    /**\n     * @dev Returns an `AddressSlot` with member `value` located at `slot`.\n     */\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\n        assembly (\"memory-safe\") {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns a `BooleanSlot` with member `value` located at `slot`.\n     */\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\n        assembly (\"memory-safe\") {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns a `Bytes32Slot` with member `value` located at `slot`.\n     */\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\n        assembly (\"memory-safe\") {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns a `Uint256Slot` with member `value` located at `slot`.\n     */\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\n        assembly (\"memory-safe\") {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns a `Int256Slot` with member `value` located at `slot`.\n     */\n    function getInt256Slot(bytes32 slot) internal pure returns (Int256Slot storage r) {\n        assembly (\"memory-safe\") {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns a `StringSlot` with member `value` located at `slot`.\n     */\n    function getStringSlot(bytes32 slot) internal pure returns (StringSlot storage r) {\n        assembly (\"memory-safe\") {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `StringSlot` representation of the string storage pointer `store`.\n     */\n    function getStringSlot(string storage store) internal pure returns (StringSlot storage r) {\n        assembly (\"memory-safe\") {\n            r.slot := store.slot\n        }\n    }\n\n    /**\n     * @dev Returns a `BytesSlot` with member `value` located at `slot`.\n     */\n    function getBytesSlot(bytes32 slot) internal pure returns (BytesSlot storage r) {\n        assembly (\"memory-safe\") {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BytesSlot` representation of the bytes storage pointer `store`.\n     */\n    function getBytesSlot(bytes storage store) internal pure returns (BytesSlot storage r) {\n        assembly (\"memory-safe\") {\n            r.slot := store.slot\n        }\n    }\n}\n"},"lib/openzeppelin-contracts/contracts/interfaces/IERC20.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (interfaces/IERC20.sol)\n\npragma solidity >=0.4.16;\n\nimport {IERC20} from \"../token/ERC20/IERC20.sol\";\n"},"lib/openzeppelin-contracts/contracts/utils/Errors.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/Errors.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Collection of common custom errors used in multiple contracts\n *\n * IMPORTANT: Backwards compatibility is not guaranteed in future versions of the library.\n * It is recommended to avoid relying on the error API for critical functionality.\n *\n * _Available since v5.1._\n */\nlibrary Errors {\n    /**\n     * @dev The ETH balance of the account is not enough to perform the operation.\n     */\n    error InsufficientBalance(uint256 balance, uint256 needed);\n\n    /**\n     * @dev A call to an address target failed. The target may have reverted.\n     */\n    error FailedCall();\n\n    /**\n     * @dev The deployment failed.\n     */\n    error FailedDeployment();\n\n    /**\n     * @dev A necessary precompile is missing.\n     */\n    error MissingPrecompile(address);\n}\n"}},"settings":{"remappings":["forge-std/=lib/forge-std/src/","@openzeppelin/contracts/=lib/openzeppelin-contracts/contracts/","@openzeppelin/contracts-upgradeable/=lib/openzeppelin-contracts-upgradeable/contracts/","@core/=lib/cash/src/","@hyper-evm-lib/=lib/hyper-evm-lib/","@mock-contracts/=lib/cash/lib/mock-contracts/src/","@pythnetwork/=lib/cash/lib/pyth-crosschain/target_chains/ethereum/sdk/solidity/","cash/=lib/cash/","createx/=lib/cash/lib/pyth-crosschain/lazer/contracts/evm/lib/createx/src/","ds-test/=lib/cash/lib/pyth-crosschain/lazer/contracts/evm/lib/createx/lib/forge-std/lib/ds-test/src/","erc4626-tests/=lib/openzeppelin-contracts-upgradeable/lib/erc4626-tests/","halmos-cheatcodes/=lib/openzeppelin-contracts-upgradeable/lib/halmos-cheatcodes/src/","hyper-evm-lib/=lib/hyper-evm-lib/","openzeppelin-contracts-upgradeable/=lib/openzeppelin-contracts-upgradeable/","openzeppelin-contracts/=lib/openzeppelin-contracts/","openzeppelin-foundry-upgrades/=lib/cash/lib/pyth-crosschain/target_chains/ethereum/sdk/stylus/pyth-mock-solidity/lib/openzeppelin-foundry-upgrades/src/","pyth-crosschain/=lib/cash/lib/pyth-crosschain/","solady/=lib/cash/lib/pyth-crosschain/lazer/contracts/evm/lib/createx/lib/solady/","solidity-stringutils/=lib/cash/lib/pyth-crosschain/target_chains/ethereum/sdk/stylus/pyth-mock-solidity/lib/openzeppelin-foundry-upgrades/lib/solidity-stringutils/"],"optimizer":{"enabled":true,"runs":10000},"metadata":{"useLiteralContent":false,"bytecodeHash":"ipfs","appendCBOR":true},"outputSelection":{"*":{"*":["abi","evm.bytecode.object","evm.bytecode.sourceMap","evm.bytecode.linkReferences","evm.deployedBytecode.object","evm.deployedBytecode.sourceMap","evm.deployedBytecode.linkReferences","evm.deployedBytecode.immutableReferences","evm.methodIdentifiers","metadata"]}},"evmVersion":"cancun","viaIR":false,"libraries":{}}}
